<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script></script><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3"><link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222"><meta name="keywords" content="Python,进阶学习,学习笔记,"><link rel="alternate" href="/atom.xml" title="mtianyan's blog" type="application/atom+xml"><meta name="description" content="进阶的基础是学会入门   Python零基础入门课程学习完之后。我继续复习进阶知识。课程知识+个人总结以及知识点标注与相关难点探究。  [√] 慕课网廖雪峰老师的: python进阶"><meta name="keywords" content="Python,进阶学习,学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="Python进阶学习笔记"><meta property="og:url" content="http://blog.mtianyan.cn/post/1d8f9861.html"><meta property="og:site_name" content="mtianyan&#39;s blog"><meta property="og:description" content="进阶的基础是学会入门   Python零基础入门课程学习完之后。我继续复习进阶知识。课程知识+个人总结以及知识点标注与相关难点探究。  [√] 慕课网廖雪峰老师的: python进阶"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/fmeLmg3Cfj.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/2D0jkLJF7L.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/j5BFgIfGL2.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/kCAJl5AELJ.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/mI85AiHJ0D.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/46d9BIKF7C.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/L4mgiEdD15.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/C6Ib1GlF8A.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/h8Ik6FD4gL.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/jamj54aBiF.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/FHdEl98B64.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/1B7l8FLjij.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/Jkbm893lC7.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/jgfCd55HCf.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/A78d86Bf66.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/EidCflgfg6.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/98jd95BjkJ.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/8LDiD7EJHL.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/4dcEACCI50.png?imageslim"><meta property="og:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180104/j3CefF1Lji.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/aCHbG7F851.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/EC9KfiGb5j.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/GKLI9Hi0kL.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/IJ2jKJHFBJ.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/mCLK742CDH.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/HbCH7j0hDf.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/1CdDk608fB.png?imageslim"><meta property="og:image" content="http://myphoto.mtianyan.cn/blog/180104/25k9LCamf4.png?imageslim"><meta property="og:updated_time" content="2018-01-04T20:28:46.271Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Python进阶学习笔记"><meta name="twitter:description" content="进阶的基础是学会入门   Python零基础入门课程学习完之后。我继续复习进阶知识。课程知识+个人总结以及知识点标注与相关难点探究。  [√] 慕课网廖雪峰老师的: python进阶"><meta name="twitter:image" content="http://oerdwodsk.bkt.clouddn.com/blog/180103/fmeLmg3Cfj.png?imageslim"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.3",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.mtianyan.cn/post/1d8f9861.html"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement("script"),n=t.getElementsByTagName("script")[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,0,("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"e28768be"}),daovoice("update")</script><title>Python进阶学习笔记 | mtianyan's blog</title><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?415372bd35fec36f7558dd96b48ec03f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/mtianyan" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">mtianyan's blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">天涯明月笙的博客小站(Github托管)</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br> 公益404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://blog.mtianyan.cn/post/1d8f9861.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="mtianyan"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="mtianyan's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Python进阶学习笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-03T16:24:58+08:00">2018-01-03</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python从入门到精通/" itemprop="url" rel="index"><span itemprop="name">python从入门到精通</span></a></span></span> <span id="/post/1d8f9861.html" class="leancloud_visitors" data-flag-title="Python进阶学习笔记"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">热度&#58;</span><span class="leancloud-visitors-count"></span> <span>℃</span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span class="post-meta-item-text">字数统计&#58;</span> <span title="字数统计">22,794</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">98</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote class="blockquote-center"><p>进阶的基础是学会入门</p></blockquote><div class="note"><p> Python零基础入门课程学习完之后。我继续复习进阶知识。课程知识+个人总结以及知识点标注与相关难点探究。</p><ul><li>[√] 慕课网廖雪峰老师的: python进阶</li></ul></div><a id="more"></a><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/fmeLmg3Cfj.png?imageslim" alt="mark"></p><p>课程详细介绍Python强大的函数式编程和面向对象编程，掌握Python高级程序设计的方法。</p><h1 id="打好基础再来进阶"><a href="#打好基础再来进阶" class="headerlink" title="打好基础再来进阶"></a>打好基础再来进阶</h1><p>在<a href="http://blog.mtianyan.cn/2018/01/02/Python%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/#more">基础入门笔记</a>中我们学到了以下知识:</p><ol><li>安装Python环境</li><li>变量和数据类型：Python内置的基本类型</li><li>List和Tuple：顺序的集合类型</li><li>条件判断和循环：控制程序流程</li><li>Dict和Set：根据key访问的集合类型</li><li>函数：定义和调用函数</li><li>切片：如何对list进行切片</li><li>迭代：如何用for循环迭代集合类型</li><li>列表生成式:如何快速生成列表</li></ol><p>注：我个人对于自认为重要的知识点都进行了<code>知识点</code>关键字标记。如果想复习的小伙伴可以<br><code>ctrl + f</code> 输入关键字 <code>知识点</code> 进行查看。<br>对于重要以及较难的编程题目我进行了关键字 <code>天涯</code>的标记。</p><p>进阶课程中将会学到的知识：</p><ul><li>函数式编程：注意与函数编程区别</li><li>模块：模块的使用</li><li>面向对象：概念，属性，方法，基础，多态。</li><li>定制类：利用Python的特殊方法定制类</li></ul><p>学习目标：<code>掌握函数式编程</code> <code>掌握面向对象编程</code> <code>能够编写模块化的程序</code></p><h1 id="Python函数式编程"><a href="#Python函数式编程" class="headerlink" title="Python函数式编程"></a>Python函数式编程</h1><p>讲解Python函数式编程概念，高阶函数的概念和实际用法，以及装饰器函数的原理和实现方式。</p><h2 id="函数式编程简介"><a href="#函数式编程简介" class="headerlink" title="函数式编程简介"></a>函数式编程简介</h2><p>函数: function,入门课程学习过的<br>函数式：functional, 一种编程范式</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/2D0jkLJF7L.png?imageslim" alt="mark"></p><p><code>函数式编程</code> 是一种抽象的编程模式</p><p>不同语言的抽象层次不同:</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/j5BFgIfGL2.png?imageslim" alt="mark"></p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/kCAJl5AELJ.png?imageslim" alt="mark"></p><p>上图中语言越往上越高级，抽象程度越高。越往上抽象就逐渐向数学接近</p><p>知识点: 函数式编程的特点:</p><ul><li>把计算视为函数而非指令(这样不贴近计算机而是贴进计算)</li><li>纯函数式编程: 不需要变量，没有副作用，测试简单。(函数任意执行多少次结果确定)</li><li>支持高阶函数，代码简洁</li></ul><p>知识点: python支持的函数式编程</p><ul><li>不是纯函数式编程：允许有变量</li><li>支持高阶函数：函数也可以作为变量传入</li><li>支持闭包：有了闭包就能返回函数</li><li>有限度的支持匿名函数。</li></ul><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数：</p><ul><li>变量可以指向函数</li></ul><p>demo:</p><p>直接输入<code>abs</code>返回的是一个函数对象。<br>而变量<code>f</code> 通过赋值运算符指向<code>abs函数对象</code><br>然后此时<code>f</code>这个函数名就可以实现调用<code>abs()</code></p><p>知识点: <strong>函数名其实就是指向函数的一个变量(一个很普通的变量)</strong></p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/mI85AiHJ0D.png?imageslim" alt="mark"></p><p><code>abs</code> 就是一个<strong>普通的</strong>变量名。通过赋值运算符指向了python内置的<code>abs函数对象</code>。<br>我们可以把它当做普通变量处理。</p><p>知识点: <strong>高阶函数高在自己能接受函数作为参数</strong></p><p>高阶函数: 能接收函数作为参数的函数。</p><ul><li>变量可以指向函数</li><li>函数的参数可以接受变量</li></ul><p>所以一个函数可以接收另一个函数作为参数。这时我们把能接收函数做参数的函数成为高阶函数。</p><p>demo: 接受abs函数</p><ul><li>定义一个函数，接收<code>x</code>,<code>y</code>,<code>f</code>三个参数。</li><li>其中<code>x</code>,<code>y</code>是数值，<code>f</code>是函数</li><li><code>def add(x,y,f)</code></li><li><code>return f(x) + f(y)</code></li></ul><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/46d9BIKF7C.png?imageslim" alt="mark"></p><p>只要我们理解: 变量可以指向函数,函数可以作为一个变量传递给另一个函数就可以了。</p><p>待探究:</p><p>如果刚才我们一直没有关闭窗口。也就是我们的<code>abs</code>变量还指向的是<code>len</code>函数对象。</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/L4mgiEdD15.png?imageslim" alt="mark"></p><p>解决方案:</p><blockquote><p>暂无待续</p></blockquote><h2 id="把函数作为参数"><a href="#把函数作为参数" class="headerlink" title="把函数作为参数"></a>把函数作为参数</h2><p>上一节我们讲了高阶函数的概念，并编写了一个简单的高阶函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure><p>如果传入<code>abs</code>作为参数<code>f</code>的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">-5</span>, <span class="number">9</span>, abs)</span><br></pre></td></tr></table></figure><p>根据函数的定义，函数执行的代码实际上是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abs(<span class="number">-5</span>) + abs(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>由于参数 <code>x</code>, <code>y</code> 和 <code>f</code>都可以任意传入，如果 <code>f</code>传入其他函数，就可以得到不同的返回值。</p><h3 id="编程任务"><a href="#编程任务" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>利用add(x,y,f)函数，计算：</p></blockquote><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/C6Ib1GlF8A.png?imageslim" alt="mark"></p><p>注意: python中的<code>sqrt</code>函数在<code>math</code>包中。需要<code>import</code>进来<br><code>import</code>的相关知识后面会讲的。这里只需要用一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># from math import sqrt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> add(<span class="number">25</span>, <span class="number">9</span>,  math.sqrt)</span><br><span class="line"><span class="comment"># 如果采用第二行import方法调用时如下</span></span><br><span class="line"><span class="keyword">print</span> add(<span class="number">25</span>, <span class="number">9</span>,  sqrt)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.0</span><br></pre></td></tr></table></figure><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p><code>map()</code>是 Python <strong>内置</strong>的高阶函数，它接收一个函数<code>f</code>和一个 <code>list</code>，并通过把函数<code>f</code><strong>依次作用</strong>在<code>list</code>的每个元素上，得到一个新的<code>list</code>并返回这个<code>list</code>。</p><p>例如，对于<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p><p>如果希望把list的每个元素都作平方，就可以用map()函数：</p><p>因此，我们只需要传入函数<code>f(x)=x*x</code>，就可以利用map()函数完成这个计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="keyword">print</span> map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 10, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>知识点； 注意：map()函数不改变原有的 list，而是<strong>返回一个新的 list</strong>。</p><p>利用<code>map()</code>函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。</p><p>由于list包含的元素可以是<strong>任何类型</strong>，因此，map() 不仅仅可以处理只包含数值的 list，事实上它可以处理包含任意类型的 list，<strong>只要传入的函数f可以处理这种数据类型</strong>。</p><h3 id="编程任务-1"><a href="#编程任务-1" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则，请利用<code>map()</code>函数.</p></blockquote><p>把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的list：</p><p>输入：<code>[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]</code><br>输出：<code>[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]</code></p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_name</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>].upper() + s[<span class="number">1</span>:].lower()</span><br><span class="line"><span class="keyword">print</span> map(format_name, [<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>])</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure><h2 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce()函数"></a>reduce()函数</h2><p><code>reduce()</code>函数也是Python<strong>内置的</strong>一个高阶函数。reduce()函数接收的参数和 map()类似，一个函数<code>f</code>，一个<code>list</code>，但<code>知识点</code>：<strong>行为和 <code>map()</code>不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。</strong></p><p>例如，编写一个<code>f</code>函数，接收<code>x</code>和<code>y</code>，返回<code>x和y的和</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def f(x, y):</span><br><span class="line">    return x + y</span><br></pre></td></tr></table></figure><p>调用 reduce(f, [1, 3, 5, 7, 9])时，reduce函数将做如下计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先计算头两个元素：f(1, 3)，结果为4；</span><br><span class="line">再把结果和第3个元素计算：f(4, 5)，结果为9；</span><br><span class="line">再把结果和第4个元素计算：f(9, 7)，结果为16；</span><br><span class="line">再把结果和第5个元素计算：f(16, 9)，结果为25；</span><br><span class="line">由于没有更多的元素了，计算结束，返回结果25。</span><br></pre></td></tr></table></figure><p>上述计算实际上是对 list 的所有元素求和。虽然Python内置了求和函数<code>sum()</code>，但是，利用reduce()求和也很简单。</p><p><code>知识点</code>：reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(f, [1, 3, 5, 7, 9], 100)</span><br></pre></td></tr></table></figure><p>结果将变为125，因为第一轮计算是：</p><ul><li>计算初始值和第一个元素：f(100, 1)，结果为101。</li></ul><h3 id="编程任务-2"><a href="#编程任务-2" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>Python内置了求和函数sum()，但没有求积的函数，请利用recude()来求积：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 4, 5, 7, 12]</span><br><span class="line">输出：2*4*5*7*12的结果</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> reduce(prod, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3360</span><br></pre></td></tr></table></figure><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><p><code>filter()</code>函数是 Python 内置的另一个有用的高阶函数，<code>filter()</code>函数接收一个函数 <code>f</code> 和一个<code>list</code>，这个函数 <code>f</code> 的作用是对每个元素进行判断，返回 <code>True</code>或 <code>False</code>，<code>filter()</code> 知识点：<strong>根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新list。</strong></p><p>例如，要从一个<code>list [1, 4, 6, 7, 9, 12, 17]</code><br>中删除偶数，保留奇数，首先，要编写一个判断奇数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后，利用<code>filter()</code>过滤掉偶数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filter(is_odd, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">17</span>])</span><br><span class="line">结果：[<span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure><p>利用<code>filter()</code>，可以完成很多有用的功能，例如，删除 <code>None</code> 或者<code>空字符串</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">filter(is_not_empty, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;test&apos;, &apos;str&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure><p>知识点:</p><p>注意: <code>s.strip(rm)</code> 删除 <code>s</code> 字符串中<code>开头、结尾处</code>的 <code>rm</code> 序列的字符。</p><p>当<code>rm</code>为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;     123&apos;</span><br><span class="line">a.strip()</span><br></pre></td></tr></table></figure><p>结果： ‘123’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=&apos;\t\t123\r\n&apos;</span><br><span class="line">a.strip()</span><br><span class="line">结果：&apos;123&apos;</span><br></pre></td></tr></table></figure><h3 id="编程任务-3"><a href="#编程任务-3" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请利用<code>filter()</code>过滤出1~100中平方根是整数的数，即结果应该是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_sqr</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.sqrt(x)%<span class="number">1</span>==<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> filter(is_sqr, range(<span class="number">1</span>, <span class="number">101</span>))</span><br></pre></td></tr></table></figure><p>注: <code>sqrt</code>函数是开根号的函数，返回值为<code>浮点数</code>。在<code>math</code>包中。</p><ul><li><code>math.sqrt(4)</code> 结果是 <code>2.0</code></li></ul><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><h2 id="自定义排序函数"><a href="#自定义排序函数" class="headerlink" title="自定义排序函数"></a>自定义排序函数</h2><p>Python内置的 sorted()函数可对list进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5, 9, 12, 21, 36]</span><br></pre></td></tr></table></figure><p><code>知识点</code>: 但 <code>sorted()</code>也是一个高阶函数，它可以<strong>接收一个比较函数</strong>来实现<strong>自定义排序</strong>，比较函数的定义是，传入两个待比较的元素 <code>x</code>, <code>y</code>，如果 <code>x</code>应该排在<code>y</code>的前面，返回<code>-1</code>，如果<code>x</code> 应该排在 <code>y</code> 的后面，返回 <code>1</code>。如果 <code>x</code> 和 <code>y</code> 相等，返回 <code>0</code>。</p><p>因此，如果我们要实现倒序排序，只需要编写一个<code>reversed_cmp</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversed_cmp</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>解析上面函数:</p><ul><li>当<code>x&gt;y</code>时，return<code>-1</code>.向<code>sorted</code>表明<code>x</code>应排在<code>y</code>的前面。也就是越大的排越靠前(俗称逆序)</li><li>其他情况同理可得</li></ul><p>这样，调用 <code>sorted()</code> 并传入 <code>reversed_cmp</code>就可以实现倒序排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">21</span>], reversed_cmp)</span><br><span class="line">[<span class="number">36</span>, <span class="number">21</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>知识点：sorted()也可以对字符串进行排序，<strong>字符串默认按照ASCII大小来比较：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br><span class="line">[<span class="string">'Credit'</span>, <span class="string">'Zoo'</span>, <span class="string">'about'</span>, <span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure><p>‘Zoo’排在’about’之前是因为’Z’的ASCII码比’a’小。</p><h3 id="编程任务-4"><a href="#编程任务-4" class="headerlink" title="编程任务"></a>编程任务</h3><p>对字符串排序时，有时候忽略大小写排序更符合习惯。请利用<code>sorted()</code>高阶函数，实现忽略大小写排序的算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[&apos;bob&apos;, &apos;about&apos;, &apos;Zoo&apos;, &apos;Credit&apos;]</span><br><span class="line">输出：[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmp_ignore_case</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> cmp(s1.lower(), s2.lower())</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], cmp_ignore_case)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>Python的函数不但可以返回<code>int、str、list、dict</code>等数据类型，还可以返回函数！</p><p>解析：因为前面我们讲过Python中的函数为高阶函数。也就是可以把函数作为一个参数使用。既然是一个参数(变量)，那么可以被用来返回也不奇怪了。</p><p>例如，定义一个函数 <code>f()</code>，我们让它返回一个函数 <code>g</code>，可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'call f()...'</span></span><br><span class="line">    <span class="comment"># 定义函数g:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call g()...'</span></span><br><span class="line">    <span class="comment"># 返回函数g:</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>仔细观察上面的函数定义，我们在函数<code>f</code>内部又定义了一个函数 <code>g</code>。由于函数 <code>g</code>也是一个对象，函数名 <code>g</code> 就是一个指向函数 <code>g</code> 的变量，所以，最外层函数 <code>f</code> 可以返回变量 <code>g</code>，也就是函数 <code>g</code> 本身。</p><p>调用函数 f，我们会得到 f 返回的一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = f()   <span class="comment"># 调用f()</span></span><br><span class="line">call f()...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x   <span class="comment"># 变量x是f()返回的函数：</span></span><br><span class="line">&lt;function g at <span class="number">0x1037bf320</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x()   <span class="comment"># x指向函数，因此可以调用</span></span><br><span class="line">call g()...   <span class="comment"># 调用x()就是执行g()函数定义的代码</span></span><br></pre></td></tr></table></figure><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/h8Ik6FD4gL.png?imageslim" alt="mark"></p><p>知识点: 图中<code>x = f()</code>对于<code>f()</code>进行调用的同时将返回值存入了<code>x</code>中。<br>因此<code>x</code>存放上了f函数的返回值: <code>g函数</code>。因为<code>x</code>指向一个函数对象。所以我们可以调用该函数对象。</p><p>请注意区分返回函数和返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs   <span class="comment"># 返回函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myabs2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x)   <span class="comment"># 返回函数调用的结果，返回值是一个数值</span></span><br></pre></td></tr></table></figure><p>知识点: 返回函数可以把一些<strong>计算延迟执行</strong>。例如，如果定义一个普通的求和函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(lst)</span><br></pre></td></tr></table></figure><p>调用calc_sum()函数时，将立刻计算并得到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; calc_sum([1, 2, 3, 4])</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>但是，如果返回一个函数，就可以<code>延迟计算</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure><p>调用calc_sum()并没有计算出结果，而是返回函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = calc_sum([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum at 0x1037bfaa0&gt;</span><br></pre></td></tr></table></figure><p>对返回的函数进行调用时，才计算出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>由于可以返回函数，我们在后续代码里就可以决定到底要不要调用该函数。</p><h3 id="编程任务-5"><a href="#编程任务-5" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请编写一个函数calc_prod(lst)，它接收一个list，返回一个函数，返回函数可以计算参数的乘积。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_prod</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> reduce((<span class="keyword">lambda</span> x, y : x * y),lst)</span><br><span class="line">    <span class="keyword">return</span> prod</span><br><span class="line"></span><br><span class="line">f = calc_prod([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">print</span> f()</span><br></pre></td></tr></table></figure><p>解析: <code>reduce((lambda x, y : x * y),lst)</code></p><p>reduce为一个高阶函数，传入两个参数。</p><ul><li>参数一为<code>(lambda x, y : x * y)</code>这是一个<code>lambda</code>函数。表示传入参数<code>x</code>,<code>y</code>。然后进行<code>x * y</code>运算。</li><li>参数二: 一个可迭代对象。</li></ul><p>过程:</p><ul><li><code>1 * 2</code>得到结果 <code>2</code></li><li><code>2 * 3</code>得到结果 <code>6</code></li><li><code>6 * 4</code>得到结果 <code>24</code></li></ul><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在函数内部定义的函数和外部定义的函数是一样的，<strong>只是他们无法被外部访问：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'g()...'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'f()...'</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>知识点；将 <code>g</code> 的定义移入函数 <code>f</code> 内部，防止其他代码调用 <code>g</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'f()...'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'g()...'</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>但是，考察上一小节定义的 <code>calc_sum</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum(lst)</span><br><span class="line">    <span class="keyword">return</span> lazy_sum</span><br></pre></td></tr></table></figure><p><code>知识点</code> 注意: 发现没法把 <code>lazy_sum</code> 移到 <code>calc_sum</code> 的外部，因为它引用了 <code>calc_sum</code> 的参数 <code>lst</code>。也就是在<code>calc_sum</code>函数外部定义的<code>lazy_sum</code>函数，就没办法接收传入<code>calc_sum</code>函数的参数。</p><p><code>知识点:python闭包的定义</code></p><p>像这种内层函数引用了外层函数的变量（参数也算变量），然后返回内层函数本身的情况，称为<strong>闭包（Closure）</strong>。</p><p>闭包的特点是<strong>返回的函数还引用了外层函数的局部变量</strong></p><ul><li>如被返回的<code>lazy_sum</code> 函数还引用了传入<code>calc_sum</code>函数的变量(局部)</li></ul><p>所以，要<code>知识点:</code> 正确使用闭包，就要确保引用的局部变量在函数返回后不能变。举例如下：</p><p>希望一次返回3个函数，分别计算1x1,2x2,3x3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f1(), f2(), f3()</span><br></pre></td></tr></table></figure><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/jamj54aBiF.png?imageslim" alt="mark"></p><p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1，4，9</code>，但实际结果全部都是 <code>9</code>。</p><p><code>知识点:</code> 原因就是当count()函数返回了3个函数时，这3个函数所引用的变量 i 的值已经变成了3。由于f1、f2、f3并没有被调用，所以，此时他们并未计算 <code>i*i</code>，当 <code>f1</code> 被调用时：</p><p><code>个人解析：</code> <code>f1, f2, f3 = count()</code>调用<code>count()</code>函数, 进入<code>count()</code>函数内部。</p><ul><li><code>fs = []</code>创建一个空的集合</li><li><code>for i in range(1, 4):</code> 循环执行三次代码块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in range(1, 4):</span><br><span class="line">        def f():</span><br><span class="line">             return i*i</span><br><span class="line">        fs.append(f)</span><br></pre></td></tr></table></figure><ul><li>第一次执行时，定义一个<code>f()</code>函数，该函数此时被直接调用时的返回值为 <code>i*i</code> ;然后将f函数作为一个元素加入空列表<code>fs</code>中。验证代码如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"我现在的返回值：%d"</span>,f()</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f1(), f2(), f3()</span><br></pre></td></tr></table></figure><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/FHdEl98B64.png?imageslim" alt="mark"></p><ul><li>然后继续执行。直到把三个函数都当做元素存入<code>fs</code>。至此<code>f1, f2, f3 = count()</code>运行完毕</li><li><code>print f1(), f2(), f3()</code> 调用这三个函数。此时<code>f()</code>被调用。执行<code>i*i</code>,但是现在的<code>i</code> 值为3.所以三个值都为9.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span>     <span class="comment"># 因为f1现在才计算i*i，但现在i的值已经变为3</span></span><br></pre></td></tr></table></figure><p><strong>因此，返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p><h3 id="编程任务-天涯"><a href="#编程任务-天涯" class="headerlink" title="编程任务(天涯)"></a>编程任务(天涯)</h3><blockquote><p>返回闭包不能引用循环变量，请改写count()函数，让它正确返回能计算<code>1x1、2x2、3x3</code>的函数。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">lambda</span> : i*i</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"><span class="keyword">print</span> f1(), f2(), f3()</span><br></pre></td></tr></table></figure><p>解析：往<code>fs</code>中添加的元素不在是<code>f函数</code>本身。此时添加的对象是<code>f函数的调用</code>也就是他被调用后的返回值<code>lambda : i*i</code> 一个<code>lambda</code>函数对象。</p><p><code>lambda : i*i</code>时它使用的变量是当次循环传入的i值。而不是循环变量<code>i</code></p><p>解析二：</p><p>考察下面的函数 f:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> j*j</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure><p>它可以正确地返回一个闭包<code>g</code>，<code>g</code>所引用的变量<code>j</code>不是循环变量，因此将正常执行。</p><p>使用下一个函数来将循环变量在单词循环之时持久化。</p><p>参考代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(j)</span>:</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">()</span>:</span></span><br><span class="line">                <span class="keyword">return</span> j*j</span><br><span class="line">            <span class="keyword">return</span> g</span><br><span class="line">        r = f(i)</span><br><span class="line">        fs.append(r)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"><span class="keyword">print</span> f1(), f2(), f3()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 9</span><br></pre></td></tr></table></figure><p>附加解法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"我现在的返回值：%d"</span>,f()</span><br><span class="line">        fs.append(f())</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> f1, f2, f3</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>高阶函数可以接收函数做参数，有些时候，我们不需要显式地定义函数，直接传入匿名函数更方便。</p><p>在Python中，对匿名函数提供了有限支持。还是以<code>map()</code>函数为例，计算 <code>f(x)=x的平方</code> 时，除了定义一个<code>f(x)</code>的函数外，还可以直接传入<code>匿名函数</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">lambda</span> x: x * x, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br></pre></td></tr></table></figure><p>通过对比可以看出，匿名函数 <code>lambda x: x * x</code>实际上就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></table></figure><p>关键字lambda 表示匿名函数，<strong>冒号前面的 x 表示函数参数</strong>。</p><p><code>知识点:</code> 匿名函数有个限制，<strong>就是只能有一个表达式，不写return，返回值就是该表达式的结果。</strong></p><p>使用匿名函数，可以不必定义函数名，直接创建一个函数对象，很多时候可以简化代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>], <span class="keyword">lambda</span> x,y: -cmp(x,y))</span><br><span class="line">[<span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>注：<code>cmp(x,y)</code> 函数用于比较2个对象，如果 <code>x &lt; y</code>返回 <code>-1</code>, 如果 <code>x == y</code> 返回 0, 如果 <code>x &gt; y</code> 返回 1。</p><p>前面我们知道排序函数。是接收到return<code>-1</code>.向<code>sorted</code>表明<code>x</code>应排在<code>y</code>的前面。也就是小的<code>x</code>排前面,那么此时是正序排列。而<code>-cmp(x,y)</code>则是逆序排列。</p><p>返回函数的时候，也可以返回匿名函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myabs = <span class="keyword">lambda</span> x: -x <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> x </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myabs(<span class="number">-1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myabs(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>解析:</p><p>匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。<br>Python lambda总共以下2种写法，一种是不含<code>if…else…</code>的，一种是包含<code>if…else…</code>的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda &lt;args&gt;: &lt;return-expression&gt;</span><br><span class="line">lambda &lt;args&gt;: &lt;return-expression&gt; if &lt;cond-expression&gt; else &lt;return-expression&gt;</span><br></pre></td></tr></table></figure><p>更多学习资源:</p><p><a href="http://locatino.github.io/2015/08/03/playing-python-lambda/" target="_blank" rel="noopener">http://locatino.github.io/2015/08/03/playing-python-lambda/</a></p><p>如果想要在匿名函数中做一些除了return-expression，其他事情（比如说print()）,应该怎么写？<br>确实不太好写，不过我还是想出了一个非常投机取巧的办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: <span class="keyword">True</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> print(x) == <span class="keyword">None</span> <span class="keyword">else</span> x<span class="string">")</span></span><br></pre></td></tr></table></figure><p>上面这个函数不仅返回了x的值，并且还打印了x.<br>这里我把需要执行的语句(print())转换成了逻辑表达式，而且是一个永远为真的表达式，它一定会执行，并且对业务的逻辑判断没有影响。<br>前提是你必须准确的知道需要执行的语句的返回值，才能写出永远为真的表达式。</p><p>and语句的短路：所以一定要保证前面x%2 == 0为真。此时<code>if x % 2 == 0 and print(x)</code><br>返回<code>print(x)</code></p><h3 id="编程任务-6"><a href="#编程任务-6" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>利用匿名函数简化以下代码：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span></span><br><span class="line">filter(is_not_empty, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> filter(<span class="keyword">lambda</span> s:s <span class="keyword">and</span> len(s.strip()) &gt; <span class="number">0</span>, [<span class="string">'test'</span>, <span class="keyword">None</span>, <span class="string">''</span>, <span class="string">'str'</span>, <span class="string">'  '</span>, <span class="string">'END'</span>])</span><br></pre></td></tr></table></figure><p>既要满足s非空，又要满足s不是结束字符等。</p><p>注意: <code>s.strip(rm)</code> 删除 <code>s</code> 字符串中<code>开头、结尾处</code>的 <code>rm</code> 序列的字符。</p><p>当<code>rm</code>为空时，默认删除空白符（包括’\n’, ‘\r’, ‘\t’, ‘ ‘)</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;test&apos;, &apos;str&apos;, &apos;END&apos;]</span><br></pre></td></tr></table></figure><h2 id="Python中的装饰器"><a href="#Python中的装饰器" class="headerlink" title="Python中的装饰器"></a>Python中的装饰器</h2><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180103/1B7l8FLjij.png?imageslim" alt="mark"></p><p>在不改变原函数的情况下，想在运行时动态的增加新功能。可以极大地简化代码，避免每个函数编写重复性代码。</p><p>示例:</p><ul><li>希望对下列函数调用增加log功能，打印出函数调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br></pre></td></tr></table></figure><p>方法一: 直接修改原函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'call f1()'</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'call f2()'</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'call f3()'</span></span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br></pre></td></tr></table></figure><p>高阶函数：</p><ul><li>可以接收函数作为参数</li><li>可以返回函数</li><li>是否可以接收一个函数，对其包装，然后返回一个新函数。</li></ul><p>方法二: 通过高阶函数返回新函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_fn</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call'</span> + f.__name__ + <span class="string">'()'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>代码解析：我们可以定义一个<code>new_fn</code>这样一个函数。接收<code>f</code>参数。<br>返回一个<code>fn新函数</code></p><ul><li>在这个新函数内部首先我们用print语句打印出了一行日志。<br>紧接着我们对原函数进行调用。返回原函数的结果。</li></ul><p>至此我们就得到了一个新的函数。它即包含了原函数的调用（也就是返回原函数调用后的值，又有一行日志来增强原函数的功能。</p><p>这里的<code>new_fn(f)</code>这个高阶函数就是装饰器函数：</p><p>知识点： 调用装饰器函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g1 = new_fn(f1)</span><br><span class="line"><span class="keyword">print</span> g1(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>向<code>new_fn</code>传入<code>f1</code>，然后会</p><ul><li>先定义一个<code>fn(x)</code>函数。</li><li>进入<code>fn(x)</code>函数内部：执行第一行打印log，然后如果有对于<code>fn(x)</code>的调用会返回传入的<code>f</code>函数并为其传入参数<code>x</code>.</li></ul><p>但是很明显：现在只是定义了这个函数<code>fn(x)</code>,并没有进行调用。</p><ul><li>所以此时<code>g1 = new_fn(f1)</code>的执行结果便是<code>new_fn</code>的返回值。返回<code>fn</code><br>对象，并被存入了<code>g1</code>变量中。此时对于<code>g1</code>的调用就是对于<code>fn</code>的调用。</li></ul><p><code>print g1(5)</code>实际就是调用了<code>fn</code>函数。</p><ul><li>即打印了日志</li><li>得到了原函数的返回值<code>return f(x)</code></li></ul><p>方法2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 = new_fn(f1)</span><br><span class="line"><span class="keyword">print</span> f1(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>将<code>f1</code>作为参数传入的<code>new_fn</code>的返回值 <code>fn</code> 保存回<code>f1</code>本身<br>因为函数名本身也是变量。所以我们就用这种方法彻底的隐藏了<code>f1</code><br>的原始定义函数。这时候f1就是装饰以后的函数。</p><p>注： <code>_name_</code> 是函数的一个属性，取到函数名。</p><p>Python内置的<code>@</code>语法就是为了简化装饰器的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@new_fn</span><br><span class="line">def f1(x):</span><br><span class="line">    return x*2</span><br></pre></td></tr></table></figure><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/Jkbm893lC7.png?imageslim" alt="mark"></p><p><strong>装饰器的作用</strong></p><p>可以极大地简化代码，避免每个函数编写重复性代码</p><ul><li>打印日志<code>@log</code></li><li>检测性能<code>@performance</code></li><li>数据库事务<code>@transaction</code></li><li>URL路由<code>@post(&#39;/register&#39;)</code></li></ul><p><code>@post(&#39;/register&#39;)</code>让这个函数来处理指定的url。</p><h2 id="编写无参数decorator"><a href="#编写无参数decorator" class="headerlink" title="编写无参数decorator"></a>编写无参数decorator</h2><p>知识点：Python的 <code>decorator</code> 本质上就是一个高阶函数，它<strong>接收一个函数作为参数，然后，返回一个新函数。</strong></p><p>使用 <code>decorator</code> 用Python提供的 <code>@</code> 语法，这样可以避免手动编写 <code>f = decorate(f)</code> 这样的代码。</p><p>考察一个<code>@log</code>的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>对于阶乘函数，@log工作得很好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call factorial()...</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure><p>但是，对于参数不是一个的函数，调用将报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">print</span> add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    print add(1,2)</span><br><span class="line">TypeError: fn() takes exactly 1 argument (2 given)</span><br></pre></td></tr></table></figure><p>因为 <code>add()</code> 函数需要传入两个参数，但是<code>@log</code>写死了只含一个参数的返回函数。</p><p>要让 <code>@log</code> 自适应任何参数定义的函数，可以利用Python的 <code>*args</code> 和 <code>**kw</code>，保证任意个数的参数总是能正常调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>现在，对于任意函数，<code>@log</code> 都能正常工作。</p><p>注：</p><ul><li><code>*args</code>表示任何多个无名参数，它是一个<code>tuple</code></li><li><code>**kw</code>表示关键字参数，它是一个<code>dict</code>。</li><li>并且同时使用<code>*args和**kwargs</code>时，必须<code>*args</code>参数列要在<code>**kw</code>前</li></ul><p>参考博客：</p><ul><li><a href="http://blog.csdn.net/feisan/article/details/1729905" target="_blank" rel="noopener">http://blog.csdn.net/feisan/article/details/1729905</a></li><li><a href="https://n3xtchen.github.io/n3xtchen/python/2014/08/08/python-args-and-kwargs" target="_blank" rel="noopener">https://n3xtchen.github.io/n3xtchen/python/2014/08/08/python-args-and-kwargs</a></li></ul><p>Python里，<code>带*的参数</code>就是用来接受可变数量参数的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcD</span><span class="params">(a, b, *c)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> a</span><br><span class="line">  <span class="keyword">print</span> b</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"length of c is: %d "</span> % len(c)</span><br><span class="line">  <span class="keyword">print</span> c</span><br></pre></td></tr></table></figure><p>调用<code>funcD(1, 2, 3, 4, 5, 6)</code>结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">length of c is: 4</span><br><span class="line">(3, 4, 5, 6)</span><br></pre></td></tr></table></figure><p>如果一个函数定义中的最后一个形参有 <code>**</code>前缀,所有正常形参之外的其他的<code>关键字参数</code>都将被放置在一个字典中传递给函数，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funcF</span><span class="params">(a, **b)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> a</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> b:</span><br><span class="line">    <span class="keyword">print</span> x + <span class="string">": "</span> + str(b[x])</span><br></pre></td></tr></table></figure><p>调用<code>funcF(100, c=&#39;你好&#39;, b=200)</code>，执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">c: 你好</span><br><span class="line">b: 200</span><br></pre></td></tr></table></figure><p>大家可以看到，<code>b</code>是一个<code>dict</code>对象实例，它接受了关键字参数<code>b</code>和<code>c</code>。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>使用 Mysql Python 库时候,经常看到这个样子的代码，db_conf 一般都从配置文件读取，这时优雅的不定字典参数就派上用途了！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector  </span><br><span class="line"></span><br><span class="line">db_conf = &#123;</span><br><span class="line">	user=<span class="string">'xx'</span>,</span><br><span class="line">	password=<span class="string">'yy'</span>, </span><br><span class="line">	host=<span class="string">'xxx.xxx.xxx.xxx'</span>,</span><br><span class="line">	database=<span class="string">'zz'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(</span><br><span class="line">	user=db_conf[<span class="string">'user'</span>],</span><br><span class="line">	password=db_conf[<span class="string">'password'</span>], </span><br><span class="line">	host=db_conf[<span class="string">'host'</span>],</span><br><span class="line">	database=db_conf[<span class="string">'database'</span>]</span><br><span class="line">	)</span><br></pre></td></tr></table></figure><p>修改版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector  </span><br><span class="line"></span><br><span class="line">db_conf = &#123;</span><br><span class="line">	user=<span class="string">'xx'</span>,</span><br><span class="line">	password=<span class="string">'yy'</span>, </span><br><span class="line">	host=<span class="string">'xxx.xxx.xxx.xxx'</span>,</span><br><span class="line">	database=<span class="string">'zz'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cnx = mysql.connector.connect(**db_conf)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="编程任务-天涯-1"><a href="#编程任务-天涯-1" class="headerlink" title="编程任务(天涯)"></a>编程任务(天涯)</h3><blockquote><p>请编写一个<code>@performance</code>，它可以打印出函数调用的时间。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_time</span><span class="params">(x)</span>:</span></span><br><span class="line">        t1= time.time()</span><br><span class="line">        res = f(x)</span><br><span class="line">        t2=time.time()</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call %s() in %fs'</span> % (f.__name__, (t2 - t1))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> log_time</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li><code>performance(f)</code>是一个高阶函数，传入一个参数：函数对象,返回包装后的新函数。</li><li><code>log_time(x)</code>是被高阶函数包裹的新函数。它复杂把旧函数的参数作为自己的参数。<br>在自己内部执行想要额外添加的功能。然后调用原函数，将原函数调用后的返回值作为自己的返回值。</li></ul><p><code>time</code>模块(参考time模块内容)</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call factorial() in 0.004899s</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure><h2 id="编写带参数decorator"><a href="#编写带参数decorator" class="headerlink" title="编写带参数decorator"></a>编写带参数decorator</h2><p>考察上一节的 <code>@log</code> 装饰器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>发现对于被装饰的函数，<code>log</code>打印的语句是不能变的（除了函数名）。</p><p>如果有的函数非常重要，希望打印出<code>&#39;[INFO] call xxx()...&#39;</code>，有的函数不太重要，希望打印出<code>&#39;[DEBUG] call xxx()...&#39;</code>，这时，<code>log</code>函数本身就需要传入<code>&#39;INFO&#39;</code>或<code>&#39;DEBUG&#39;</code>这样的参数，类似这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log('DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>把上面的定义翻译成高阶函数的调用，就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_func = log(&apos;DEBUG&apos;)(my_func)</span><br></pre></td></tr></table></figure><p>解：<code>log(&#39;DEBUG&#39;)(my_func)</code>装饰器函数<code>log(&#39;DEBUG&#39;)&#39;</code>被调用传入<code>my_func</code>原函数对象</p><p>上面的语句看上去还是比较绕，再展开一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log_decorator = log(&apos;DEBUG&apos;)</span><br><span class="line">my_func = log_decorator(my_func)</span><br></pre></td></tr></table></figure><p>也就是装饰器函数本身是<code>log(&#39;DEBUG&#39;)</code>,然后为该函数调用时传入参数<code>my_func</code></p><p>上面的语句又相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log_decorator = log(&apos;DEBUG&apos;)</span><br><span class="line">@log_decorator</span><br><span class="line">def my_func():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>知识点：所以，带参数的<code>log</code>函数首先返回一个<code>decorator</code>函数，再让这个d<code>ecorator</code>函数接收<code>my_func</code>并返回新函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'[%s] %s()...'</span> % (prefix, f.__name__)</span><br><span class="line">            <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> log_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log('DEBUG')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> test()</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] test()...</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>与上一节无参数做比较:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call '</span> + f.__name__ + <span class="string">'()...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure><p>可以看出它在log(f)的上层又多加了一层函数外壳。使得<br>带参数的log函数首先返回一个decorator函数。</p><p>知识点：无参数装饰器为两层结构。有参数装饰器为三层结构</p><p>对于这种<code>3层嵌套</code>的<code>decorator</code>定义，你可以先把它拆开：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'[%s] %s()...'</span> % (prefix, f.__name__)</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回decorator:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(prefix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> log_decorator(f)</span><br></pre></td></tr></table></figure><p>拆开以后会发现，调用会失败，因为在3层嵌套的<code>decorator</code>定义中，最内层的<code>wrapper</code>引用了最外层的参数<code>prefix</code>，所以，<strong>把一个闭包拆成普通的函数调用会比较困难。</strong>不支持闭包的编程语言要实现同样的功能就需要更多的代码。</p><p>那么我们如何拆开才能保证正确呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未完待续</span><br></pre></td></tr></table></figure><h3 id="编程任务-天涯-2"><a href="#编程任务-天涯-2" class="headerlink" title="编程任务(天涯)"></a>编程任务(天涯)</h3><p>上一节的<code>@performance</code>只能打印秒，请给 <code>@performace</code>增加一个参数，允许传入<code>&#39;s&#39;</code>或<code>&#39;ms&#39;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@performance('ms')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>实现代码(天涯):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(unit)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perf_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            t1 = time.time()</span><br><span class="line">            r = f(*args, **kw)</span><br><span class="line">            t2 = time.time()</span><br><span class="line">            t = (t2 - t1)*<span class="number">1000</span> <span class="keyword">if</span> unit ==<span class="string">'ms'</span> <span class="keyword">else</span> (t2 - t1)</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'call %s() in %f %s'</span>%(f.__name__, t, unit)</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> perf_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('ms')  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>最外层输入：参数<code>unit</code>，返回：接收了参数的装饰器函数对象。</li><li>次外层输入：参数<code>f</code> 函数对象。返回: 被包装过的函数对象<code>wrapper</code></li><li>最内层输入：参数为<code>*args, **kw</code>。进行额外的处理加返回：返回<code>f</code>函数调用的返回值。</li></ul><p>人肉运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perf_decorator = performance(&apos;ms&apos;)</span><br><span class="line">factorial = perf_decorator(factorial(10))</span><br><span class="line">factorial = wrapper</span><br><span class="line">factorial(10) = wrapper(10)</span><br><span class="line"># 然后执行 print 并返回 f(*args, **kw)的值</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call factorial() in 6.043911 ms</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure><h2 id="完善decorator"><a href="#完善decorator" class="headerlink" title="完善decorator"></a>完善decorator</h2><p><code>@decorator</code>可以动态实现函数功能的增加，但是，经过<code>@decorator</code>“改造”后的函数，和原函数相比，除了功能多一点外，有没有其它不同的地方？</p><p>在没有decorator的情况下，打印函数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f1.__name__</span><br></pre></td></tr></table></figure><p>输出： <code>f1</code></p><p>有decorator的情况下，再打印函数名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">print</span> f2.__name__</span><br></pre></td></tr></table></figure><p>输出： <code>wrapper</code></p><p>可见，由于<code>decorator</code>返回的新函数函数名已经不是<code>&#39;f2&#39;</code>，而是<code>@log</code>内部定义的<code>&#39;wrapper&#39;</code>。这对于那些依赖函数名的代码就会失效。<code>decorator</code>还改变了函数的<code>__doc__</code>等其它属性。<code>知识点:</code> 如果要让调用者看不出一个函数经过了<code>@decorator</code>的“改造”，<strong>就需要把原函数的一些属性复制到新函数中：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    wrapper.__name__ = f.__name__</span><br><span class="line">    wrapper.__doc__ = f.__doc__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>这样写<code>decorator</code>很不方便，因为我们也很难把原函数的所有必要属性都一个一个复制到新函数上，所以Python内置的<code>functools</code>可以用来自动化完成这个“复制”的任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>最后需要指出，由于我们把原函数签名改成了<code>(*args, **kw)</code>，因此，<strong>无法获得原函数的原始参数信息。</strong>即便我们采用固定参数来装饰只有一个参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'call...'</span></span><br><span class="line">        <span class="keyword">return</span> f(x)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>也可能改变原函数的参数名，因为新函数的参数名始终是 <code>&#39;x&#39;</code>，原函数定义的参数名不一定叫 <code>&#39;x&#39;</code>。</p><h3 id="编程任务-7"><a href="#编程任务-7" class="headerlink" title="编程任务"></a>编程任务</h3><p>请思考带参数的<code>@decorator</code>，<code>@functools.wraps</code>应该放置在哪：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(unit)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perf_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            ???</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> perf_decorator</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(unit)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perf_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kv)</span>:</span></span><br><span class="line">            t0 = time.time()</span><br><span class="line">            r = f(*args,**kv)</span><br><span class="line">            t1 = time.time()</span><br><span class="line">            t = (t1 - t0) <span class="keyword">if</span> unit ==<span class="string">'s'</span> <span class="keyword">else</span> (t1 - t0) * <span class="number">1000</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">'call %s() in %s %s'</span> % (f.__name__, t, unit)</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perf_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@performance('ms')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y: x*y, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> factorial.__name__</span><br></pre></td></tr></table></figure><p>tips:</p><ul><li>最外层输入：参数<code>unit</code>，返回：接收了参数的装饰器函数对象。</li><li>次外层输入：参数<code>f</code> 函数对象。返回: 被包装过的函数对象<code>wrapper</code></li><li>最内层输入：参数为<code>*args, **kw</code>。进行额外的处理加返回：返回<code>f</code>函数调用的返回值。</li></ul><p>搞清每一层的输入输出就可以成功写出来</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factorial</span><br></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>当一个函数有很多参数时，调用者就需要提供多个参数。如果减少参数个数，就可以简化调用者的负担。</p><p>比如，<code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按<code>十进制</code>转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>)</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入base参数，就可以做<code>N</code>进制的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>, base=<span class="number">8</span>)</span><br><span class="line"><span class="number">5349</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'12345'</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">74565</span></span><br></pre></td></tr></table></figure><p><code>知识点</code>：假设要转换大量的二进制字符串，每次都传入<code>int(x, base=2)</code>非常麻烦，于是，我们想到，可以定义一个<code>int2()</code>的函数，默认把<code>base=2</code>传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int2</span><span class="params">(x, base=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> int(x, base)</span><br></pre></td></tr></table></figure><p>这样，我们转换二进制就非常方便了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1000000'</span>)</span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int2(<span class="string">'1010101'</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure><p><code>functools.partial</code>就是帮助我们创建一个<strong>偏函数</strong>的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 = functools.partial(int, base=2)</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1000000&apos;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&apos;1010101&apos;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure><p>所以，<code>functools.partial</code>可以把一个参数多的函数变成一个参数少的新函数，少的参数需要在创建时指定<strong>默认值</strong>，这样，新函数调用的难度就降低了。</p><p><code>知识点</code>：偏函数是为一个多参数函数设定参数的默认值，可以降低函数调用的难度。</p><h3 id="编程任务-8"><a href="#编程任务-8" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>在第7节中，我们在<code>sorted</code>这个高阶函数中传入自定义排序函数就可以实现忽略大小写排序。请用<code>functools.partial</code>把这个复杂调用变成一个简单的函数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted_ignore_case(iterable)</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">sorted_ignore_case = functools.partial(sorted,key=str.lower)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> sorted_ignore_case([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>])</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;]</span><br></pre></td></tr></table></figure><p><code>functools.partial</code> 传入两个参数，一个是原函数。一个是原函数包含的默认参数。</p><p>官方文档对于<code>sorted</code>的说明：</p><p>key specifies a function of one argument that is used to extract a comparison key from each list <code>element:key=str.lower</code>. The default value isNone.</p><p>课外知识：</p><p><code>sort</code> 与 <code>sorted</code> 区别：</p><ul><li><code>sort</code> 是应用在 <code>list</code> 上的方法，<code>sorted</code> 可以对<code>所有可迭代的对象</code>进行排序操作。</li><li><code>list</code> 的 <code>sort</code> 方法返回的是对已经存在的列表进行操作，而内建函数 <code>sorted</code>方法返回的是一个新的 <code>list</code>，而不是在原来的基础上进行的操作。</li></ul><p><code>sorted</code> 语法：</p><p><code>sorted(iterable[, cmp[, key[, reverse]]])</code></p><p>参数说明：</p><ul><li>iterable – 可迭代对象。</li><li>cmp – 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li><li>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li></ul><h1 id="Python的模块"><a href="#Python的模块" class="headerlink" title="Python的模块"></a>Python的模块</h1><p>如何编写和导入模块，以及如何安装并使用第三方模块</p><h2 id="模块和包。"><a href="#模块和包。" class="headerlink" title="模块和包。"></a>模块和包。</h2><p>概念：模块和包。</p><p>当我们的代码越来越多的时候:</p><ul><li>将所有代码放入一个py文件:难以维护</li></ul><p>我们如果将代码分拆放入多个py文件,好处:</p><pre><code>- 同一个名字变量互不影响
</code></pre><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/jgfCd55HCf.png?imageslim" alt="mark"></p><p>存在于两个文件中的同名变量，函数互不影响。</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/A78d86Bf66.png?imageslim" alt="mark"></p><p>这时我们称文件<code>a</code>为<code>模块a</code>,<code>b</code>为<code>模块b</code>.</p><p>知识点： 模块的名字就是python文件的名字。</p><p>引用其他模块方法：</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/EidCflgfg6.png?imageslim" alt="mark"></p><p>当模块变多之后他们很容易重名。</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/98jd95BjkJ.png?imageslim" alt="mark"></p><p>路人甲与路人乙都写了<code>util.py</code>,产生了冲突。</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/8LDiD7EJHL.png?imageslim" alt="mark"></p><p>同名的模块放入不同的包中。就可以了。<br>此时即使有同名的模块，但是他们的完整名字变成了<code>p1.util</code> 和 <code>p2.util</code><br>，就不冲突了。</p><ul><li>引用完整模块</li></ul><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/4dcEACCI50.png?imageslim" alt="mark"></p><p>全部都要写完整名称。<code>p1.util</code> <code>p1.util.f(2,10)</code></p><ul><li>包就是文件夹</li><li>模块就是<code>xxx.py</code>文件</li><li>包可以有多级</li></ul><p>区分包和普通目录</p><p>包下面必须有一个<code>__init__.py</code>这样一个特殊的文件。<br>每一个包的<strong>每一层目录</strong>都要有这个文件。</p><p>即使这个文件是空文件，也必须让这个文件存在。这样Python才能识别这是一个包。</p><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>要使用一个模块，我们必须首先导入该模块。Python使用<code>import</code>语句导入一个模块。例如，导入<strong>系统自带</strong>的模块 <code>math</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure><p>你可以认为<code>math</code>就是一个指向已导入模块的变量，通过该变量，我们可以访问math模块中所定义的所有公开的函数、变量和类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pow(<span class="number">2</span>, <span class="number">0.5</span>) <span class="comment"># pow是函数</span></span><br><span class="line"><span class="number">1.4142135623730951</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.pi <span class="comment"># pi是变量</span></span><br><span class="line"><span class="number">3.141592653589793</span></span><br></pre></td></tr></table></figure><p>注意：<code>pow()</code>方法返回 <code>x的y次方</code> 的值。</p><p>内置的 <code>pow()</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(x, y[, z])</span><br></pre></td></tr></table></figure><p>函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于<code>pow(x,y) %z</code><br>但是会更有效率一点。</p><p>如果我们只希望导入用到的<code>math</code>模块的某几个函数，而不是所有函数，可以用下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from math import pow, sin, log</span><br></pre></td></tr></table></figure><p>这样，可以直接引用 <code>pow</code>, <code>sin</code>, <code>log</code> 这3个函数，但<code>math</code>的其他函数没有导入进来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(2, 10)</span><br><span class="line">1024.0</span><br><span class="line">&gt;&gt;&gt; sin(3.14)</span><br><span class="line">0.0015926529164868282</span><br></pre></td></tr></table></figure><p>如果遇到名字冲突怎么办？比如<code>math</code>模块有一个<code>log</code>函数，<code>logging</code>模块也有一个<code>log</code>函数，如果同时使用，如何解决名字冲突？</p><p>如果使用<code>import</code>导入模块名，由于<strong>必须通过模块名引用函数名，因此不存在冲突：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import math, logging</span><br><span class="line">print math.log(10)   # 调用的是math的log函数</span><br><span class="line">logging.log(10, &apos;something&apos;)   # 调用的是logging的log函数</span><br></pre></td></tr></table></figure><p>如果使用 <code>from...import</code> 导入 <code>log</code> 函数，势必引起冲突。这时，可以给函数起个<strong>“别名”</strong>来避免冲突：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"><span class="keyword">from</span> logging <span class="keyword">import</span> log <span class="keyword">as</span> logger   <span class="comment"># logging的log现在变成了logger</span></span><br><span class="line"><span class="keyword">print</span> log(<span class="number">10</span>)   <span class="comment"># 调用的是math的log</span></span><br><span class="line">logger(<span class="number">10</span>, <span class="string">'import from logging'</span>)   <span class="comment"># 调用的是logging的log</span></span><br></pre></td></tr></table></figure><h3 id="编程任务-9"><a href="#编程任务-9" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>Python的<code>os.path</code>模块提供了 <code>isdir()</code> 和 <code>isfile()</code>函数，请导入该模块，并调用函数判断指定的目录和文件是否存在。</p></blockquote><p>注意: 可以在本机上测试是否存在相应的文件夹和文件。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">print</span> os.path.isdir(<span class="string">r'C:\Windows'</span>)</span><br><span class="line"><span class="keyword">print</span> os.path.isfile(<span class="string">r'C:\Windows\notepad.exe'</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="动态导入模块"><a href="#动态导入模块" class="headerlink" title="动态导入模块"></a>动态导入模块</h2><p>如果导入的模块不存在，Python解释器会报 <code>ImportError</code> 错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> something</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: No module named something</span><br></pre></td></tr></table></figure><p>有的时候，两个不同的模块提供了相同的功能，比如 <code>StringIO</code> 和 <code>cStringIO</code> 都提供了<code>StringIO</code>这个功能。</p><p>这是因为Python是动态语言，解释执行，因此Python代码运行速度慢。</p><p>如果要提高Python代码的运行速度，最简单的方法是把某些关键函数用 C 语言重写，这样就能大大提高执行速度。</p><p>同样的功能，<code>StringIO</code> 是纯Python代码编写的，而 <code>cStringIO</code> <strong>部分</strong>函数是 C 写的，因此 <code>cStringIO</code>运行速度更快。</p><p>利用<code>ImportError</code>错误，我们经常在Python中<strong>动态</strong>导入模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> cStringIO <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> StringIO <span class="keyword">import</span> StringIO</span><br></pre></td></tr></table></figure><p>上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。</p><p><code>try</code> 的作用是捕获错误，并在捕获到指定错误时执行 <code>except</code> 语句。</p><p>这里先用一下，更多内容在Python错误与异常处理中讲。</p><h3 id="编程任务-10"><a href="#编程任务-10" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>利用<code>import ... as ...，</code>还可以动态导入不同名称的模块。<br>Python 2.6/2.7提供了<code>json</code> 模块，但Python 2.5以及更早版本没有json模块，不过可以安装一个<code>simplejson</code>模块，这两个模块提供的函数签名和功能都一模一样。</p></blockquote><p>试写出导入json 模块的代码，能在Python 2.5/2.6/2.7都正常运行。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> simplejson</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> json.dumps(&#123;<span class="string">'python'</span>:<span class="number">2.7</span>&#125;)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：Python的<code>Json</code>模块<code>序列化</code>与<code>反序列化</code>的过程分别是 <code>encoding</code>和 <code>decoding</code></p><ul><li>encoding(编码)：把一个<code>Python对象编码</code>转换成<code>Json</code>字符串</li><li>decoding(解码)：把<code>Json</code>格式字符串解码转换成<code>Python对象</code></li></ul><p>对于简单数据类型<code>string、unicode、int、float、list、tuple、dict</code>，可以直接处理。</p><p><code>json.dumps</code>方法对简单数据类型<code>encoding</code></p><p><code>知识点</code>联系对比：</p><p>在Python入门中接触的<code>Unicode</code>编码中。</p><ul><li><code>decode</code>的作用是将其他编码的字符串转换成<code>unicode</code>编码，如<code>str1.decode(&#39;gb2312&#39;)</code>，表示将<code>gb2312</code>编码的字符串<code>str1</code>转换成<code>unicode</code>编码。</li><li><code>encode</code>的作用是将<code>unicode</code>编码转换成其他编码的字符串，如<code>str2.encode(‘gb2312’)</code>，表示将<code>unicode</code>编码的字符串<code>str2</code>转换成<code>gb2312</code>编码</li></ul><h2 id="使用future"><a href="#使用future" class="headerlink" title="使用future"></a>使用<strong>future</strong></h2><p>Python的新版本会引入新的功能，但是，实际上这些功能在上一个老版本中就已经存在了。要“试用”某一新的特性，就可以通过导入<code>__future__</code>模块的某些功能来实现。</p><p>例如，Python 2.7的整数除法运算结果仍是整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>python2.7下：</p><p><img src="http://oerdwodsk.bkt.clouddn.com/blog/180104/j3CefF1Lji.png?imageslim" alt="mark"></p><p>但是，Python 3.x已经改进了整数的除法运算，<code>/</code>除将得到浮点数，<code>//</code>除才仍是整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.3333333333333335</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> // <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>要在Python 2.7中引入3.x的除法规则，导入<code>__future__</code>的<code>division</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="number">10</span> / <span class="number">3</span></span><br><span class="line"><span class="number">3.3333333333333335</span></span><br></pre></td></tr></table></figure><p>当新版本的一个特性与旧版本不兼容时，该特性将会在旧版本中添加到<code>__future__</code>中，以便旧的代码能在旧版本中测试新特性。</p><h3 id="编程任务-11"><a href="#编程任务-11" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>在Python 3.x中，字符串统一为<code>unicode</code>，不需要加前缀 <code>u</code>，而以字节存储的<code>str</code>则必须加前缀 <code>b</code>。请利用<code>__future__</code>的<code>unicode_literals</code>在Python 2.7中编写<code>unicode</code>字符串。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line">s = <span class="string">'am I an unicode?'</span></span><br><span class="line"><span class="keyword">print</span> isinstance(s, unicode)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h2><p>虽然内置了许多模块，但是很多有用的第三方包需要我们自己下载。</p><p>两种方法安装第三方模块</p><ul><li>easy_install</li><li>pip install(推荐，因为pip内置)</li></ul><p>我推荐安装的<strong>Anaconda</strong>也已经内置了<code>pip</code></p><p>安装体验。</p><p><code>pip install web.py</code></p><p>cmd下进入python命令行就可以导入web.py了</p><p>查找第三方模块名字：</p><p><a href="https://pypi.python.org/pypi" target="_blank" rel="noopener">https://pypi.python.org/pypi</a></p><p>在这里可以搜索。</p><h1 id="Python面向对象编程"><a href="#Python面向对象编程" class="headerlink" title="Python面向对象编程"></a>Python面向对象编程</h1><p>如何创建类和实例，如何定义类的属性和方法。</p><h2 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h2><p>面向对象编程是一种程序设计范式: 把程序看做不同对象的相互调用。</p><p>是对于<strong>现实世界</strong>建立的对象模型。</p><p>面向对象编程的基本思想(类和实例):</p><ul><li><code>类</code>：用于定于抽象类型（比如人、汽车、花等抽象的一类事物）</li><li><code>实例</code>：根据类的定义被创建出来的</li></ul><p>类的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>通过类创建具体的实例，通过类名与一个类似于函数调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person()</span><br><span class="line">xiaojun = Person()</span><br><span class="line">xiaohong = Person()</span><br></pre></td></tr></table></figure><p>比如人的实例有小明、小胡等具体的人，他们有年龄、性别和爱好等不同的属性和方法</p><p><strong>面向对象最重要的思想就是：数据封装</strong></p><p>在类中把数据封装起来。不同的实例它具有相同的数据类型，但是他拥有不同的属性。</p><h2 id="定义类并创建实例"><a href="#定义类并创建实例" class="headerlink" title="定义类并创建实例"></a>定义类并创建实例</h2><p>在Python中，类通过 <code>class</code> 关键字定义。以 <code>Person</code> 为例，定义一个<code>Person</code>类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>按照 Python 的编程习惯，<strong>类名以大写字母开头，紧接着是(object)</strong>，表示该类是从哪个类<code>继承</code>下来的。类的继承将在后面的章节讲解，现在我们只需要简单地从object类继承。</p><p>有了<code>Person</code>类的定义，就可以创建出具体的<code>xiaoming、xiaohong</code>等实例。创建实例使用 <code>类名+()</code>，类似函数调用的形式创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person()</span><br><span class="line">xiaohong = Person()</span><br></pre></td></tr></table></figure><h3 id="编程任务-12"><a href="#编程任务-12" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请练习定义Person类，并创建出两个实例，打印实例，再比较两个实例是否相等。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">xiaoming = Person()</span><br><span class="line">xiaohong = Person()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> xiaoming</span><br><span class="line"><span class="keyword">print</span> xiaohong</span><br><span class="line"><span class="keyword">print</span> xiaoming==xiaohong</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Person instance at 0x7f434c37d050&gt;</span><br><span class="line">&lt;__main__.Person instance at 0x7f434c3813f8&gt;</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h2 id="创建实例属性"><a href="#创建实例属性" class="headerlink" title="创建实例属性"></a>创建实例属性</h2><p>虽然可以通过<code>Person</code>类创建出<code>xiaoming、xiaohong</code>等实例，但是这些实例看上除了地址不同外，没有什么其他不同。在现实世界中，区分<code>xiaoming、xiaohong</code>要依靠他们各自的<code>名字</code>、<code>性别</code>、<code>生日</code>等属性。</p><p>如何让每个实例拥有各自不同的属性？由于Python是动态语言，对每一个实例，都可以直接给他们的属性赋值.</p><p>例如，给xiaoming这个实例加上<code>name、gender和birth</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person()</span><br><span class="line">xiaoming.name = <span class="string">'Xiao Ming'</span></span><br><span class="line">xiaoming.gender = <span class="string">'Male'</span></span><br><span class="line">xiaoming.birth = <span class="string">'1990-1-1'</span></span><br></pre></td></tr></table></figure><p>给xiaohong加上的属性不一定要和xiaoming相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaohong = Person()</span><br><span class="line">xiaohong.name = <span class="string">'Xiao Hong'</span></span><br><span class="line">xiaohong.school = <span class="string">'No. 1 High School'</span></span><br><span class="line">xiaohong.grade = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>实例的属性可以像普通变量一样进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaohong.grade = xiaohong.grade + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="编程任务-13"><a href="#编程任务-13" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请创建包含两个 Person 类的实例的 list，并给两个实例的 name 赋值，然后按照 name 进行排序。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p1.name = <span class="string">'Bart'</span></span><br><span class="line"></span><br><span class="line">p2 = Person()</span><br><span class="line">p2.name = <span class="string">'Adam'</span></span><br><span class="line"></span><br><span class="line">p3 = Person()</span><br><span class="line">p3.name = <span class="string">'Lisa'</span></span><br><span class="line"></span><br><span class="line">L1 = [p1, p2, p3]</span><br><span class="line">L2 = sorted(L1,key=<span class="keyword">lambda</span> x:x.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> L2[<span class="number">0</span>].name</span><br><span class="line"><span class="keyword">print</span> L2[<span class="number">1</span>].name</span><br><span class="line"><span class="keyword">print</span> L2[<span class="number">2</span>].name</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Adam</span><br><span class="line">Bart</span><br><span class="line">Lisa</span><br></pre></td></tr></table></figure><p>python3下该代码只需要<code>print</code>加上括号。也可以正常运行。</p><h2 id="初始化实例属性"><a href="#初始化实例属性" class="headerlink" title="初始化实例属性"></a>初始化实例属性</h2><p>虽然我们可以自由地给一个实例绑定各种属性，但是，现实世界中，一种类型的实例应该拥有相同名字的属性。例如，<strong>Person</strong>类应该在创建的时候就拥有<code>name</code>、<code>gender</code> 和 <code>birth</code> 属性，怎么办？</p><p>在定义 <code>Person</code> 类时，可以为Person类添加一个特殊的<code>__init__()</code>方法被自动调用，我们就能在此为每个实例都统一加上以下属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, birth)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.birth = birth</span><br></pre></td></tr></table></figure><p><code>__init__()</code> 方法的第一个参数必须是 <code>self</code>（<strong>也可以用别的名字，但建议使用习惯用法</strong>），后续参数则可以自由指定，和定义函数没有任何区别。</p><p>相应地，创建实例时，就<strong>必须要提供除 self 以外的参数</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1991-1-1'</span>)</span><br><span class="line">xiaohong = Person(<span class="string">'Xiao Hong'</span>, <span class="string">'Female'</span>, <span class="string">'1992-2-2'</span>)</span><br></pre></td></tr></table></figure><p>有了<code>__init__()</code>方法，每个<code>Person</code>实例在创建时，都会有 <code>name</code>、<code>gender</code> 和<code>birth</code> 这3个属性，并且，被赋予不同的属性值，访问属性使用.操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> xiaoming.name</span><br><span class="line"><span class="comment"># 输出 'Xiao Ming'</span></span><br><span class="line"><span class="keyword">print</span> xiaohong.birth</span><br><span class="line"><span class="comment"># 输出 '1992-2-2'</span></span><br></pre></td></tr></table></figure><p>知识点：要特别注意的是，初学者定义<code>__init__()</code>方法常常忘记了 <code>self</code> 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(name, gender, birth)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: __init__() takes exactly <span class="number">3</span> arguments (<span class="number">4</span> given)</span><br></pre></td></tr></table></figure><p>这会导致创建失败或运行不正常，因为第一个参数name被Python解释器传入了实例的引用，从而导致整个方法的调用参数位置全部没有对上。</p><h3 id="编程任务-14"><a href="#编程任务-14" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请定义Person类的<code>__init__</code>方法，除了接受 <code>name、gender 和 birth</code> 外，还可接受任意关键字参数，并把他们都作为属性赋值给实例。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, birth,**kw)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.birth = birth</span><br><span class="line">        self.__dict__.update(kw)</span><br><span class="line">        <span class="comment"># setattr(self, k, v)也可以 </span></span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">'Xiao Ming'</span>, <span class="string">'Male'</span>, <span class="string">'1990-1-1'</span>, job=<span class="string">'Student'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> xiaoming.name</span><br><span class="line"><span class="keyword">print</span> xiaoming.job</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xiao Ming</span><br><span class="line">Student</span><br></pre></td></tr></table></figure><p><code>**kw</code>是一个可变的存入<code>dict</code>的变量。</p><p>知识点:</p><ul><li><code>self.__dict__.update(kw)</code></li></ul><p>解释器内部会将<code>**kw</code>拆分成对应的dict.</p><p><code>setattr()</code>方法接受3个参数：<code>setattr(对象，属性，属性的值)</code></p><p><code>setattr(self,k,v)</code>相当于<code>self.k = v</code></p><p><code>kw.iteritems()</code>历遍字典kw的所有<code>key</code>和<code>value</code>，分别匹配k，v</p><p>我们在运行期定义的属性和类定义时定义的属性都被放在了<code>__dict__</code>里。</p><p>推荐文章：<a href="http://hbprotoss.github.io/posts/python-descriptor.html" target="_blank" rel="noopener">http://hbprotoss.github.io/posts/python-descriptor.html</a></p><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>我们可以给一个实例绑定很多属性，如果有些属性不希望被外部访问到怎么办？</p><p>Python对属性权限的控制是通过<strong>属性名</strong>来实现的，如果一个属性由<code>双下划线</code>开头<code>(__)</code>，该属性就无法被外部访问。看例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self._title = <span class="string">'Mr'</span></span><br><span class="line">        self.__job = <span class="string">'Student'</span></span><br><span class="line">p = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> p.name</span><br><span class="line"><span class="comment"># =&gt; Bob</span></span><br><span class="line"><span class="keyword">print</span> p._title</span><br><span class="line"><span class="comment"># =&gt; Mr</span></span><br><span class="line"><span class="keyword">print</span> p.__job</span><br><span class="line"><span class="comment"># =&gt; Error</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Person'</span> object has no attribute <span class="string">'__job'</span></span><br></pre></td></tr></table></figure><p>可见，只有以双下划线开头的<code>__job</code>不能直接被外部访问。</p><p>知识点： 但是，如果一个属性以<code>__xxx__</code>的形式定义，那它又可以被外部访问了，以”<strong>xxx</strong>“定义的属性在Python的类中被称为<strong>特殊属性</strong>，有很多<code>知识点:</code><strong>预定义</strong>的特殊属性可以使用，通常我们不要把普通属性用<code>__xxx__</code>定义。</p><p>以单下划线开头的属性<code>_xxx</code>虽然也可以被外部访问，但是，按照习惯，他们<strong>不应该被外部访问</strong>。</p><h3 id="编程任务-15"><a href="#编程任务-15" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请给Person类的<code>__init__</code>方法中添加<code>name</code>和<code>score</code>参数，并把<code>score</code>绑定到<code>__score</code>属性上，看看外部是否能访问到。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.name</span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line">    <span class="keyword">print</span> p.__score</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attributeerror'</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bob</span><br><span class="line">attributeerror</span><br></pre></td></tr></table></figure><h2 id="创建类属性"><a href="#创建类属性" class="headerlink" title="创建类属性"></a>创建类属性</h2><p>类是<code>模板</code>，而实例则是根据类创建的对象。</p><p><code>知识点:</code> 绑定在一个实例上的属性不会影响其他实例，但是，类本身也是一个对象，如果在类上绑定一个属性，则所有实例都可以访问类的属性，并且，所有实例访问的类属性都是同一个！也就是说，实例属性每个实例各自拥有，互相独立，<strong>而类属性有且只有一份。</strong></p><p>定义类属性可以直接在 <code>class</code> 中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>因为类属性是直接绑定在类上的，所以，<code>知识点：</code> 访问<code>类属性</code>不需要<code>创建实例</code>，就可以<strong>直接访问</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> Person.address</span><br><span class="line"><span class="comment"># =&gt; Earth</span></span><br></pre></td></tr></table></figure><p>对一个实例调用类的属性也是可以访问的，所有实例都可以访问到它所属的类的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="keyword">print</span> p1.address</span><br><span class="line"><span class="comment"># =&gt; Earth</span></span><br><span class="line"><span class="keyword">print</span> p2.address</span><br><span class="line"><span class="comment"># =&gt; Earth</span></span><br></pre></td></tr></table></figure><p>由于Python是动态语言，<strong>类属性也是可以动态添加和修改的：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.address = &apos;China&apos;</span><br><span class="line">print p1.address</span><br><span class="line"># =&gt; &apos;China&apos;</span><br><span class="line">print p2.address</span><br><span class="line"># =&gt; &apos;China&apos;</span><br></pre></td></tr></table></figure><p>因为<strong>类属性只有一份，所以，当Person类的address改变时，所有实例访问到的类属性都改变了</strong>。</p><h3 id="编程任务-16"><a href="#编程任务-16" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请给 <code>Person</code> 类添加一个类属性 <code>count</code>，每创建一个实例，<code>count</code> 属性就加 1，这样就可以统计出一共创建了多少个 Person 的实例。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line">        Person.count=Person.count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> Person.count</span><br><span class="line"></span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"><span class="keyword">print</span> Person.count</span><br><span class="line"></span><br><span class="line">p3 = Person(<span class="string">'Tim'</span>)</span><br><span class="line"><span class="keyword">print</span> Person.count</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="类属性和实例属性名字冲突怎么办"><a href="#类属性和实例属性名字冲突怎么办" class="headerlink" title="类属性和实例属性名字冲突怎么办"></a>类属性和实例属性名字冲突怎么办</h2><p>修改类属性会导致所有实例访问到的类属性全部都受影响，但是，如果在实例变量上修改类属性会发生什么问题呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    address = <span class="string">'Earth'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address</span><br><span class="line"></span><br><span class="line">p1.address = <span class="string">'China'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'p1.address = '</span> + p1.address</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Person.address = '</span> + Person.address</span><br><span class="line"><span class="keyword">print</span> <span class="string">'p2.address = '</span> + p2.address</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.address = Earth</span><br><span class="line">p1.address = China</span><br><span class="line">Person.address = Earth</span><br><span class="line">p2.address = Earth</span><br></pre></td></tr></table></figure><p>我们发现，在设置了 <code>p1.address = &#39;China&#39;</code> 后，<code>p1</code>访问 <code>address</code> 确实变成了 <code>China</code>，但是，<code>Person.address</code>和<code>p2.address</code>仍然是<code>Earth</code>，怎么回事？</p><p>知识点: 原因是 <code>p1.address = &#39;China&#39;</code>并没有改变 <code>Person</code> 的 <code>address</code>，而是给<code>p1</code>这个实例绑定了<code>实例属性address</code> ，对p1来说，它有一个<strong>实例属性address（值是’China’）</strong>，而它所属的类Person也有一个类属性address，所以:</p><ul><li>访问 p1.address 时，优先查找实例属性，返回’China’。</li><li>访问 p2.address 时，p2没有实例属性address，但是有类属性address，因此返回’Earth’。</li></ul><p>知识点：当实例属性和类属性重名时，<strong>实例属性优先级高，它将屏蔽掉对类属性的访问。</strong></p><p>当我们把 <code>p1</code> 的 <code>address</code> 实例属性删除后，访问 <code>p1.address</code> 就又返回类属性的值 <code>&#39;Earth&#39;</code>了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del p1.address</span><br><span class="line">print p1.address</span><br><span class="line"># =&gt; Earth</span><br></pre></td></tr></table></figure><p>可见，<strong>千万不要在实例上修改类属性</strong>，它实际上并没有修改类属性，而是给实例绑定了一个实例属性。</p><h3 id="编程任务-17"><a href="#编程任务-17" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请把上节的 <code>Person</code> 类属性 <code>count</code> 改为 <code>__count</code>，再试试能否从实例和类访问该属性。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Person.__count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> Person.__count</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">print</span> Person.__count</span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'attributeerror'</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">attributeerror</span><br></pre></td></tr></table></figure><h2 id="定义实例方法"><a href="#定义实例方法" class="headerlink" title="定义实例方法"></a>定义实例方法</h2><p>一个实例的<code>私有属性</code>就是以<code>__</code>开头的属性，无法被外部访问，那这些属性定义有什么用？</p><p>虽然私有属性无法从外部访问，但是，从类的内部是可以访问的。除了可以定义实例的属性外，还可以定义<strong>实例的方法</strong>。</p><p>实例的方法就是在类中定义的函数，<strong>它的第一个参数永远是 self，指向调用该方法的实例本身，</strong>其他参数和一个普通函数是完全一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name\</span><br></pre></td></tr></table></figure><p><code>get_name(self)</code> 就是一个实例方法，它的第一个参数是<code>self</code>。<code>__init__(self, name)</code>其实也可看做是一个特殊的实例方法。</p><p>调用实例方法必须在实例上调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_name()  <span class="comment"># self不需要显式传入</span></span><br><span class="line"><span class="comment"># =&gt; Bob</span></span><br></pre></td></tr></table></figure><p>在实例方法内部，可以访问所有实例属性，这样，<strong>如果外部需要访问私有属性</strong>，可以通过方法调用获得，这种数据封装的形式除了<strong>能保护内部数据一致性外</strong>，还可以简化外部调用的难度。</p><h3 id="编程任务-18"><a href="#编程任务-18" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请给 Person 类增加一个私有属性 <code>__score</code>，表示分数，再增加一个实例方法 <code>get_grade()</code>，能根据 <code>__score</code> 的值分别返回 <code>A-优秀, B-及格, C-不及格</code>三档。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        score = self.__score</span><br><span class="line">        <span class="keyword">if</span> score &gt;<span class="number">85</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> score &gt;<span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">elif</span> score &lt;<span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>, <span class="number">65</span>)</span><br><span class="line">p3 = Person(<span class="string">'Tim'</span>, <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p1.get_grade()</span><br><span class="line"><span class="keyword">print</span> p2.get_grade()</span><br><span class="line"><span class="keyword">print</span> p3.get_grade()</span><br></pre></td></tr></table></figure><p>注：可以在访问数据时顺便通过<code>get_grade</code>做一些其他操作。</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><h2 id="方法也是属性"><a href="#方法也是属性" class="headerlink" title="方法也是属性"></a>方法也是属性</h2><p>我们在 <code>class</code>中定义的<code>实例方法</code>其实也是<code>属性</code>，它实际上是一个<code>函数对象</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade</span><br><span class="line"><span class="comment"># =&gt; &lt;bound method Person.get_grade of &lt;__main__.Person object at 0x109e58510&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> p1.get_grade()</span><br><span class="line"><span class="comment"># =&gt; A</span></span><br></pre></td></tr></table></figure><p><code>知识点:</code> 也就是说，<code>p1.get_grade</code> 返回的是一个函数对象，但这个函数是一个绑定到实例的函数，<code>p1.get_grade()</code> 才是方法调用。</p><p>知识点；因为方法也是一个属性，所以，它也可以动态地添加到实例上，只是需要用 <code>types.MethodType()</code> 把一个函数变为一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn_get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.score &gt;= <span class="number">80</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">if</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line">p1.get_grade = types.MethodType(fn_get_grade, p1, Person)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade()</span><br><span class="line"><span class="comment"># =&gt; A</span></span><br><span class="line">p2 = Person(<span class="string">'Alice'</span>, <span class="number">65</span>)</span><br><span class="line"><span class="keyword">print</span> p2.get_grade()</span><br><span class="line"><span class="comment"># ERROR: AttributeError: 'Person' object has no attribute 'get_grade'</span></span><br><span class="line"><span class="comment"># 因为p2实例并没有绑定get_grade</span></span><br></pre></td></tr></table></figure><p>知识点: <code>types.MethodType</code>传入三个参数，(方法，对象，类)实现将函数变为对象的一个方法。</p><p>给一个实例动态添加方法并不常见，直接在<code>class</code>中定义要更直观。</p><h3 id="编程任务-19"><a href="#编程任务-19" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>由于属性可以是普通的值对象，如 <code>str，int</code>等，也可以是方法，还可以是函数，大家看看下面代码的运行结果，请想一想 <code>p1.get_grade</code> 为什么是函数而不是方法：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.get_grade = <span class="keyword">lambda</span>: <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade</span><br><span class="line"><span class="keyword">print</span> p1.get_grade()</span><br></pre></td></tr></table></figure><p>注：</p><ul><li><code>p1.get_grade</code>是属性，只不过这里的属性是一个函数对象，即<code>f</code></li><li><code>p1.get_grade()</code>是方法，前面的p1就是调用这个方法的对象</li></ul><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.get_grade = <span class="keyword">lambda</span>: <span class="string">'A'</span></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>, <span class="number">90</span>)</span><br><span class="line"><span class="keyword">print</span> p1.get_grade</span><br><span class="line"><span class="keyword">print</span> p1.get_grade()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> at 0x7fa7202fb5f0&gt;</span><br><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="定义类方法"><a href="#定义类方法" class="headerlink" title="定义类方法"></a>定义类方法</h2><p>和属性类似，方法也分<code>实例方法</code>和<code>类方法</code>。</p><p>在class中定义的全部是<code>实例方法</code>，实例方法第一个参数 <code>self</code> 是实例本身。</p><p>要在class中定义类方法，需要这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">how_many</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Person.count = Person.count + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br></pre></td></tr></table></figure><p><code>知识点:</code> 通过标记一个 <code>@classmethod</code>，该方法将绑定到 Person 类上，而非类的实例。<strong>类方法的第一个参数将传入类本身，通常将参数名命名为 cls</strong>，上面的 <code>cls.count</code>实际上相当于 <code>Person.count</code>。</p><p><code>知识点:</code> 因为是在类上调用，而非实例上调用，因此类方法无法获得任何实例变量，只能获得类的引用。</p><h3 id="编程任务-20"><a href="#编程任务-20" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>如果将类属性 <code>count</code> 改为私有属性<code>__count</code>，则外部无法读取<code>__score</code>，但可以通过一个类方法获取，请编写类方法获得<code>__count</code>值。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __count = <span class="number">0</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">how_many</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__count</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Person.__count = Person.__count + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">'Bob'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Person.how_many()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="Python类的继承"><a href="#Python类的继承" class="headerlink" title="Python类的继承"></a>Python类的继承</h1><p>如何判断实例类型，多态以及如何获取对象信息。</p><h2 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h2><p>继承：</p><ul><li>新类不必从头编写，</li><li>可以直接从现有类继承，就自动拥有了现有类的所有功能，</li><li>新类只需要编写现有类缺少的新功能即可。</li></ul><p>继承优点：</p><ul><li>复用已有代码</li><li>自动拥有了现有类的所有功能</li><li>只需要编写缺少的新功能</li></ul><p><img src="http://myphoto.mtianyan.cn/blog/180104/aCHbG7F851.png?imageslim" alt="mark"></p><p>会形成一棵继承树</p><p>继承的特点：</p><ul><li>子类和父类是is关系</li></ul><p><img src="http://myphoto.mtianyan.cn/blog/180104/EC9KfiGb5j.png?imageslim" alt="mark"><br><img src="http://myphoto.mtianyan.cn/blog/180104/GKLI9Hi0kL.png?imageslim" alt="mark"></p><p>如果一个实例是一个子类，则它也是一个父类；如果实例是父类，则它不是子类。<br><code>is</code>关系指的是：小狗是鸟，却不能说动物是小狗</p><p><code>has</code>关系指的是：学生有一本书，不能说学生是一本书</p><p>两个<code>has</code>关系的类不能继承，只能以属性组合到类中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , bookName)</span>:</span></span><br><span class="line">        self.book=Book(bookName)</span><br></pre></td></tr></table></figure><p>继承特点：</p><ol><li>总是从某个类继承，没有合适的类时使用<code>object</code>类继承</li><li>调用<code>super().__init__</code>方法（用来初始化父类），如果不用父类的属性有可能没有被正确初始化。</li></ol><p><code>Student</code>类从父类继承<code>name</code>和<code>gender</code>：</p><p><code>super(Student,self).__init__(name,gender)</code>调用这一句来初始化父类。</p><h2 id="继承一个类"><a href="#继承一个类" class="headerlink" title="继承一个类"></a>继承一个类</h2><p>如果已经定义了<code>Person</code>类，需要定义新的<code>Student</code>和<code>Teacher</code>类时，可以直接从<code>Person</code>类继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br></pre></td></tr></table></figure><p>定义<code>Student</code>类时，只需要把额外的属性加上，例如<code>score</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p><code>知识点：</code>一定要用 <code>super(Student, self).__init__(name, gender)</code>去初始化父类，否则，继承自 <code>Person</code>的 <code>Student</code> 将没有 <code>name</code> 和 <code>gender</code>。</p><p>函数<code>super(Student, self)</code>将返回当前类继承的父类，即 <code>Person</code> ，然后调用<code>__init__()</code>方法，注意<code>self</code>参数已在<code>super()</code>中传入，在<strong>init</strong>()中将隐式传递，<strong>不需要写出（也不能写）</strong>。</p><h3 id="编程任务-21"><a href="#编程任务-21" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请参考 <code>Student</code> 类，编写一个 <code>Teacher</code>类，也继承自 <code>Person</code>。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, course)</span>:</span></span><br><span class="line">        super(Teacher, self).__init__(name, gender)</span><br><span class="line">        self.course = course</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">t = Teacher(<span class="string">'Alice'</span>, <span class="string">'Female'</span>, <span class="string">'English'</span>)</span><br><span class="line"><span class="keyword">print</span> t.name</span><br><span class="line"><span class="keyword">print</span> t.course</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Alice</span><br><span class="line">English</span><br></pre></td></tr></table></figure><h2 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h2><p>函数<code>isinstance()</code>可以判断一个<code>变量的类型</code>，既可以用在Python内置的数据类型如<code>str、list、dict</code>，也可以用在我们自定义的类，<code>它们本质上都是数据类型</code>。</p><p>假设有如下的 <code>Person</code>、<code>Student</code> 和 <code>Teacher</code> 的定义及继承关系如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, course)</span>:</span></span><br><span class="line">        super(Teacher, self).__init__(name, gender)</span><br><span class="line">        self.course = course</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Tim'</span>, <span class="string">'Male'</span>)</span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, <span class="number">88</span>)</span><br><span class="line">t = Teacher(<span class="string">'Alice'</span>, <span class="string">'Female'</span>, <span class="string">'English'</span>)</span><br></pre></td></tr></table></figure><p>当我们拿到变量 <code>p</code>、<code>s</code>、<code>t</code> 时，可以使用 <code>isinstance</code> 判断类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(p, Person)</span><br><span class="line"><span class="keyword">True</span>    <span class="comment"># p是Person类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(p, Student)</span><br><span class="line"><span class="keyword">False</span>   <span class="comment"># p不是Student类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(p, Teacher)</span><br><span class="line"><span class="keyword">False</span>   <span class="comment"># p不是Teacher类型</span></span><br></pre></td></tr></table></figure><p>这说明在继承链上，一个父类的实例不能是子类类型，因为<strong>子类比父类多了一些属性和方法。</strong></p><p>我们再考察 <code>s</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, Person)</span><br><span class="line"><span class="keyword">True</span>    <span class="comment"># s是Person类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, Student)</span><br><span class="line"><span class="keyword">True</span>    <span class="comment"># s是Student类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(s, Teacher)</span><br><span class="line"><span class="keyword">False</span>   <span class="comment"># s不是Teacher类型</span></span><br></pre></td></tr></table></figure><p><code>s</code>是<code>Student</code>类型，不是<code>Teacher</code>类型，这很容易理解。但是，<code>s</code> 也是<code>Person</code>类型，因为<code>Student</code>继承自<code>Person</code>，虽然它比<strong>Person多了一些属性和方法</strong>，但是，把 s 看成Person的实例也是可以的。</p><p>这说明在一条继承链上，<strong>一个实例可以看成它本身的类型，也可以看成它父类的类型。</strong></p><h3 id="编程任务-22"><a href="#编程任务-22" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请根据继承链的类型转换，依次思考 <code>t</code>是否是 <code>Person，Student，Teacher，object</code>类型，并使用<code>isinstance()</code>判断来验证您的答案。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, course)</span>:</span></span><br><span class="line">        super(Teacher, self).__init__(name, gender)</span><br><span class="line">        self.course = course</span><br><span class="line"></span><br><span class="line">t = Teacher(<span class="string">'Alice'</span>, <span class="string">'Female'</span>, <span class="string">'English'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> isinstance(t, Person)</span><br><span class="line"><span class="keyword">print</span> isinstance(t, Student)</span><br><span class="line"><span class="keyword">print</span> isinstance(t, Teacher)</span><br><span class="line"><span class="keyword">print</span> isinstance(t, object)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>类具有继承关系，并且子类类型可以向上转型看做父类类型，如果我们从 <code>Person</code> 派生出<code>Student</code>和<code>Teacher</code> ，并都写了一个<code>whoAmI()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whoAmI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am a Person, my name is %s'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whoAmI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am a Student, my name is %s'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, course)</span>:</span></span><br><span class="line">        super(Teacher, self).__init__(name, gender)</span><br><span class="line">        self.course = course</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whoAmI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am a Teacher, my name is %s'</span> % self.name</span><br></pre></td></tr></table></figure><p>在一个函数中，如果我们接收一个变量 x，则无论该 x 是 Person、Student还是 Teacher，都可以正确打印出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">who_am_i</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> x.whoAmI()</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Tim'</span>, <span class="string">'Male'</span>)</span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, <span class="number">88</span>)</span><br><span class="line">t = Teacher(<span class="string">'Alice'</span>, <span class="string">'Female'</span>, <span class="string">'English'</span>)</span><br><span class="line"></span><br><span class="line">who_am_i(p)</span><br><span class="line">who_am_i(s)</span><br><span class="line">who_am_i(t)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am a Person, my name is Tim</span><br><span class="line">I am a Student, my name is Bob</span><br><span class="line">I am a Teacher, my name is Alice</span><br></pre></td></tr></table></figure><p><code>知识点</code>：这种行为称为多态。也就是说，方法调用将作用在 <code>x</code>的实际类型上。<code>s 是Student类型</code>，它实际上拥有自己的 <code>whoAmI()</code>方法以及从 <code>Person继承的 whoAmI方法</code>，但调用 <code>s.whoAmI()</code>总是先查找它自身的定义，如果没有定义，则顺着继承链向上查找，直到在某个父类中找到为止。</p><p>由于Python是动态语言，所以，传递给函数 <code>who_am_i(x)</code>的参数 <code>x</code> 不一定是 <code>Person</code> 或 <code>Person 的子类型</code>。任何数据类型的实例都可以，只要它有一个whoAmI()的方法即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whoAmI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am a book'</span></span><br></pre></td></tr></table></figure><p>知识点：这是动态语言和静态语言（例如Java）最大的差别之一。动态语言调用实例方法，不检查类型，只要方法存在，参数正确，就可以调用。</p><h3 id="编程任务-23"><a href="#编程任务-23" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>Python提供了<code>open()</code>函数来打开一个磁盘文件，并返回 <code>File</code>对象。<code>File对象</code>有一个<code>read()</code>方法可以读取文件内容：</p></blockquote><p>例如，从文件读取内容并解析为JSON结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">'/path/to/file.json'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">print</span> json.load(f)</span><br></pre></td></tr></table></figure><p>由于Python的动态特性，<code>json.load()</code>并不一定要从一个<code>File对象</code>读取内容。任何对象，只要有<code>read()</code>方法，就称为<code>File-like Object</code>，都可以传给<code>json.load()</code>。</p><p>请尝试编写一个<code>File-like Object</code>，把一个字符串 <code>r&#39;[&quot;Tim&quot;, &quot;Bob&quot;, &quot;Alice&quot;]&#39;包装成 File-like Object</code> 并由 <code>json.load()</code> 解析。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, strlist)</span>:</span></span><br><span class="line">        self.strlist = strlist</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span>(self.strlist)</span><br><span class="line"></span><br><span class="line">s = Students(<span class="string">'["Tim", "Bob", "Alice"]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> json.load(s)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[u&apos;Tim&apos;, u&apos;Bob&apos;, u&apos;Alice&apos;]</span><br></pre></td></tr></table></figure><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>除了从<code>一个</code>父类继承外，Python允许从<code>多个父类</code>继承，称为<strong>多重继承。</strong></p><p>多重继承的继承链就不是一棵树了，它像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'init A...'</span></span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        super(B, self).__init__(a)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'init B...'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        super(C, self).__init__(a)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'init C...'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a)</span>:</span></span><br><span class="line">        super(D, self).__init__(a)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'init D...'</span></span><br></pre></td></tr></table></figure><p>看下图:</p><p><img src="http://myphoto.mtianyan.cn/blog/180104/IJ2jKJHFBJ.png?imageslim" alt="mark"></p><p>像这样，<code>D</code> 同时继承自 <code>B</code>和 <code>C</code>，也就是 <code>D</code> 拥有了 <code>A、B、C</code>的全部功能。多重继承通过 <code>super()</code>调用<code>__init__()</code>方法时，A 虽然被继承了两次，但<code>__init__()</code>只调用一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D(<span class="string">'d'</span>)</span><br><span class="line">init A...</span><br><span class="line">init C...</span><br><span class="line">init B...</span><br><span class="line">init D...</span><br></pre></td></tr></table></figure><p>多重继承的目的是从<strong>两种继承树中分别选择并继承出子类，</strong>以便组合功能使用。</p><p>举个例子，Python的网络服务器有<code>TCPServer</code>、<code>UDPServer</code>、<code>UnixStreamServer</code>、<code>UnixDatagramServer</code>，而服务器运行模式有 多进程<code>ForkingMixin</code> 和 多线程<code>ThreadingMixin</code>两种。</p><p>要创建多进程模式的 <code>TCPServer</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, ForkingMixin)</span></span></span><br><span class="line"><span class="class">    <span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>要创建多线程模式的 <code>UDPServer</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUDPServer</span><span class="params">(UDPServer, ThreadingMixin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果没有<strong>多重继承，要实现上述所有可能的组合需要 4x2=8 个子类</strong>。</p><h3 id="编程任务-24"><a href="#编程任务-24" class="headerlink" title="编程任务"></a>编程任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-Person</span><br><span class="line">  +- Student</span><br><span class="line">  +- Teacher</span><br><span class="line"></span><br><span class="line">是一类继承树；</span><br><span class="line"></span><br><span class="line">+- SkillMixin</span><br><span class="line">   +- BasketballMixin</span><br><span class="line">   +- FootballMixin</span><br><span class="line"></span><br><span class="line">是一类继承树。</span><br></pre></td></tr></table></figure><p>通过多重继承，请定义“会打篮球的学生”和“会踢足球的老师”。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkillMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasketballMixin</span><span class="params">(SkillMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'basketball'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FootballMixin</span><span class="params">(SkillMixin)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">skill</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'football'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BStudent</span><span class="params">(BasketballMixin,Student)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FTeacher</span><span class="params">(FootballMixin,Teacher)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">s = BStudent()</span><br><span class="line"><span class="keyword">print</span> s.skill()</span><br><span class="line"></span><br><span class="line">t = FTeacher()</span><br><span class="line"><span class="keyword">print</span> t.skill()</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basketball</span><br><span class="line">football</span><br></pre></td></tr></table></figure><h2 id="获取对象信息-知识点"><a href="#获取对象信息-知识点" class="headerlink" title="获取对象信息(知识点)"></a>获取对象信息(知识点)</h2><p>拿到一个变量，除了用<code>isinstance()</code>判断它是否是某种类型的实例外，还有没有别的方法获取到更多的信息呢？</p><p>例如，已有定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">whoAmI</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'I am a Student, my name is %s'</span> % self.name</span><br></pre></td></tr></table></figure><p>首先可以用 <code>type()</code> 函数获取变量的类型，它返回一个 <code>Type 对象</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, <span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Student</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>其次，可以用 <code>dir()</code> 函数获取变量的<code>所有属性</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="number">123</span>)   <span class="comment"># 整数也有很多属性...</span></span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(s)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'gender'</span>, <span class="string">'name'</span>, <span class="string">'score'</span>, <span class="string">'whoAmI'</span>]</span><br></pre></td></tr></table></figure><p>对于实例变量，<code>dir()</code>返回所有实例属性，包括<code>__class__</code>这类有特殊意义的属性。注意到方法<code>whoAmI</code>也是 <code>s</code> 的一个属性。</p><p>如何去掉<code>__xxx__</code>这类的特殊属性，只保留我们自己定义的属性？回顾一下filter()函数的用法。</p><p><code>dir()</code>返回的属性是字符串列表，如果已知一个属性名称，要获取或者设置对象的属性，就需要用 <code>getattr()</code> 和 <code>setattr( )</code>函数了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s, <span class="string">'name'</span>)  <span class="comment"># 获取name属性</span></span><br><span class="line"><span class="string">'Bob'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(s, <span class="string">'name'</span>, <span class="string">'Adam'</span>)  <span class="comment"># 设置新的name属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name</span><br><span class="line"><span class="string">'Adam'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s, <span class="string">'age'</span>)  <span class="comment"># 获取age属性，但是属性不存在，报错：</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'age'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(s, <span class="string">'age'</span>, <span class="number">20</span>)  <span class="comment"># 获取age属性，如果属性不存在，就返回默认值20：</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="编程任务-25"><a href="#编程任务-25" class="headerlink" title="编程任务"></a>编程任务</h3><p>对于Person类的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>希望除了 <code>name</code>和<code>gender</code> 外，可以提供任意<code>额外的关键字参数</code>，并绑定到实例，请修改 Person 的 <code>__init__()</code>定 义，完成该功能。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> kw.items():</span><br><span class="line">            setattr(self, k, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Bob'</span>, <span class="string">'Male'</span>, age=<span class="number">18</span>, course=<span class="string">'Python'</span>)</span><br><span class="line"><span class="keyword">print</span> p.age</span><br><span class="line"><span class="keyword">print</span> p.course</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">Python</span><br></pre></td></tr></table></figure><h1 id="Python的特殊方法-魔术方法"><a href="#Python的特殊方法-魔术方法" class="headerlink" title="Python的特殊方法(魔术方法)"></a>Python的特殊方法(魔术方法)</h1><p>以及如何利用特殊方法定制类，实现各种强大的功能。</p><h2 id="什么是特殊方法？"><a href="#什么是特殊方法？" class="headerlink" title="什么是特殊方法？"></a>什么是特殊方法？</h2><p>demo：</p><p>比较<code>print</code>的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print lst</span><br><span class="line">[1,2,3]</span><br></pre></td></tr></table></figure><p><img src="http://myphoto.mtianyan.cn/blog/180104/mCLK742CDH.png?imageslim" alt="mark"></p><p>对于一个<code>Person</code>类的实例进行<code>print</code>，会得到一个对象地址。</p><p>python如何把任意变量变成str?</p><p>python能够将任意变量变成str是因为任何数据类型的实例都有一个特殊方法：<code>__str__()</code><br>思考：Person类并没有定义<code>__str__()</code>，为什么能调用？</p><p><img src="http://myphoto.mtianyan.cn/blog/180104/HbCH7j0hDf.png?imageslim" alt="mark"></p><p>对应调用<code>list</code>和<code>Person</code>实例的<code>__str__()</code>方法。</p><p>如果我们给Person类加上特殊方法<code>__str__()</code>，我们就可以根据自己需要打印出Person实例来。<br><img src="http://myphoto.mtianyan.cn/blog/180104/1CdDk608fB.png?imageslim" alt="mark"></p><ul><li>用于print的<strong>str</strong></li><li>用于len的<strong>len</strong></li><li>用于cmp的<strong>cmp</strong></li></ul><p>python的特殊方法特点：</p><ul><li>特殊方法定义在<code>class</code>中</li><li>不需要直接调用</li><li>python的某些函数或操作符会自动调用对应的特殊方法。</li></ul><p>Python定义的一部分特殊方法:</p><p><img src="http://myphoto.mtianyan.cn/blog/180104/25k9LCamf4.png?imageslim" alt="mark"></p><p>正确实现特殊方法：</p><ul><li>只需编写用到的特殊方法</li><li>有关联性的特殊方法都必须实现</li></ul><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__getattr__</span><br><span class="line">__setattr__</span><br><span class="line">__delattr__</span><br></pre></td></tr></table></figure><p>这三个方法需要同时编写</p><h2 id="str-和-repr"><a href="#str-和-repr" class="headerlink" title="__str__和__repr__"></a><code>__str__</code>和<code>__repr__</code></h2><p>如果要把一个类的实例变成 <code>str</code>，就需要实现特殊方法<code>__str__()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(Person: %s, %s)'</span> % (self.name, self.gender)</span><br></pre></td></tr></table></figure><p>现在，在交互式命令行下用 print 试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">'Bob'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> p</span><br><span class="line">(Person: Bob, male)</span><br></pre></td></tr></table></figure><p>但是，如果直接敲变量 p：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p</span><br><span class="line">&lt;main.Person object at 0x10c941890&gt;</span><br></pre></td></tr></table></figure><p>似乎<code>__str__()</code>不会被调用。</p><p><code>知识点</code>: 因为 Python 定义了<code>__str__()</code>和<code>__repr__()</code>两种方法，<code>__str__()</code>用于显示给用户，而<code>__repr__()</code>用于显示给开发人员。</p><p>有一个偷懒的定义<code>__repr__</code>的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(Person: %s, %s)'</span> % (self.name, self.gender)</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure><h3 id="编程任务-26"><a href="#编程任务-26" class="headerlink" title="编程任务"></a>编程任务</h3><p>请给<code>Student</code> 类定义<code>__str__</code>和<code>__repr__</code>方法，使得能打印出<code>&lt;Student: name, gender, score&gt;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        super(Student, self).__init__(name, gender)</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(Student: %s, %s, %s)'</span> % (self.name, self.gender, self.score)</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">88</span>)</span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Student: Bob, male, 88)</span><br></pre></td></tr></table></figure><h2 id="cmp"><a href="#cmp" class="headerlink" title="__cmp__"></a><code>__cmp__</code></h2><p>对 <code>int、str</code> 等内置数据类型排序时，Python的 <code>sorted()</code> 按照默认的比较函数 <code>cmp</code>排序，但是，如果对一组 <code>Student 类</code>的实例排序时，就必须提供我们自己的特殊方法 <code>__cmp__()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s: %s)'</span> % (self.name, self.score)</span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.name &lt; s.name:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> self.name &gt; s.name:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上述 Student 类实现了<code>__cmp__()</code>方法，<code>__cmp__</code>用实例自身<code>self</code>和传入的实例<code>s</code>进行比较，如果 <code>self</code> 应该排在前面，就返回 <code>-1</code>，如果 <code>s</code>应该排在前面，就返回<code>1</code>，如果两者相当，返回 <code>0</code>。</p><p><code>Student</code>类实现了按<code>name</code>进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [Student(<span class="string">'Tim'</span>, <span class="number">99</span>), Student(<span class="string">'Bob'</span>, <span class="number">88</span>), Student(<span class="string">'Alice'</span>, <span class="number">77</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sorted(L)</span><br><span class="line">[(Alice: <span class="number">77</span>), (Bob: <span class="number">88</span>), (Tim: <span class="number">99</span>)]</span><br></pre></td></tr></table></figure><p>注意: 如果<code>list</code>不仅仅包含 <code>Student</code> 类，则 <code>__cmp__</code> 可能会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [Student(<span class="string">'Tim'</span>, <span class="number">99</span>), Student(<span class="string">'Bob'</span>, <span class="number">88</span>), <span class="number">100</span>, <span class="string">'Hello'</span>]</span><br><span class="line"><span class="keyword">print</span> sorted(L)</span><br></pre></td></tr></table></figure><p>请思考如何解决。<br>(未完待续)</p><h3 id="编程任务-27"><a href="#编程任务-27" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请修改 <code>Student</code> 的 <code>__cmp__</code> 方法，让它按照分数从高到底排序，分数相同的按名字排序。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s: %s)'</span> % (self.name, self.score)</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score&gt;s.score:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.score&lt;s.score:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.name&lt;s.name:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.nae&gt;s.name:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">L = [Student(<span class="string">'Tim'</span>, <span class="number">99</span>), Student(<span class="string">'Bob'</span>, <span class="number">88</span>), Student(<span class="string">'Alice'</span>, <span class="number">99</span>)]</span><br><span class="line"><span class="keyword">print</span> sorted(L)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(Alice: 99), (Tim: 99), (Bob: 88)]</span><br></pre></td></tr></table></figure><h2 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h2><p>如果一个类表现得像一个<code>list</code>，要获取有多少个元素，就得用 <code>len()</code> 函数。</p><p>要让 <code>len()</code> 函数工作正常，类必须提供一个特殊方法<code>__len__()</code>，它返回元素的个数。</p><p>例如，我们写一个 <code>Students</code> 类，把名字传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        self.names = args</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.names)</span><br></pre></td></tr></table></figure><p>只要正确实现了<code>__len__()</code>方法，就可以用len()函数返回<code>Students实例</code>的“长度”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ss = Students(&apos;Bob&apos;, &apos;Alice&apos;, &apos;Tim&apos;)</span><br><span class="line">&gt;&gt;&gt; print len(ss)</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="编程任务-天涯-3"><a href="#编程任务-天涯-3" class="headerlink" title="编程任务(天涯)"></a>编程任务(天涯)</h3><p>斐波那契数列是由 <code>0, 1, 1, 2, 3, 5, 8...</code>构成。</p><p>请编写一个<code>Fib</code>类，<code>Fib(10)</code>表示数列的前10个元素，<code>print Fib(10)</code>可以打印出数列的前 10 个元素，<code>len(Fib(10))</code>可以正确返回数列的个数<code>10</code>。</p><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.fibo = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; self.num:</span><br><span class="line">            self.fibo.append(self.fibo[i<span class="number">-2</span>] + self.fibo[i<span class="number">-1</span>])</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.fibo)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.fibo)</span><br><span class="line"></span><br><span class="line">f = Fib(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> f</span><br><span class="line"><span class="keyword">print</span> len(f)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>Python 提供的基本数据类型 <code>int、float</code>以做整数和浮点的四则运算以及乘方等运算。</p><p>但是，四则运算不局限于int和float，还可以是<code>有理数、矩阵</code>等。</p><p>要表示有理数，可以用一个<code>Rational类</code>来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Rational(object):</span><br><span class="line">    def __init__(self, p, q):</span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br></pre></td></tr></table></figure><p>p、q 都是整数，表示有理数 p/q。</p><p>如果要让<code>Rational</code>进行<code>+</code>运算，需要正确实现<code>__add__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rational(self.p * r.q + self.q * r.p, self.q * r.q)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s/%s'</span> % (self.p, self.q)</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure><p>现在可以试试有理数加法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r1 = Rational(1, 3)</span><br><span class="line">&gt;&gt;&gt; r2 = Rational(1, 2)</span><br><span class="line">&gt;&gt;&gt; print r1 + r2</span><br><span class="line">5/6</span><br></pre></td></tr></table></figure><h3 id="编程任务-天涯-4"><a href="#编程任务-天涯-4" class="headerlink" title="编程任务(天涯)"></a>编程任务(天涯)</h3><blockquote><p><code>Rational</code>类虽然可以做加法，但无法做减法、乘方和除法，请继续完善Rational类，实现四则运算。</p></blockquote><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">减法运算：__sub__</span><br><span class="line">乘法运算：__mul__</span><br><span class="line">除法运算：__div__</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcs</span><span class="params">(a,b,c=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span>==a%<span class="number">2</span> <span class="keyword">and</span> <span class="number">0</span>==b%<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> gcs(a/<span class="number">2</span>,b/<span class="number">2</span>,c*<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">    s = abs(a-b)</span><br><span class="line">    m = min(a,b)</span><br><span class="line">    <span class="keyword">if</span> s == m:</span><br><span class="line">        <span class="keyword">return</span> m*c</span><br><span class="line">    <span class="keyword">return</span> gcs(s,m,c)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rational(self.p * r.q + self.q * r.p, self.q * r.q)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rational(self.p * r.q - self.q * r.p, self.q * r.q)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rational(self.p * r.p, self.q * r.q)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__div__</span><span class="params">(self, r)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Rational(self.p * r.q , self.q * r.p)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        c = gcs(self.p, self.q)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s/%s'</span> % (self.p/c, self.q/c)</span><br><span class="line"></span><br><span class="line">    __repr__ = __str__</span><br><span class="line"></span><br><span class="line">r1 = Rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">r2 = Rational(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> r1 + r2</span><br><span class="line"><span class="keyword">print</span> r1 - r2</span><br><span class="line"><span class="keyword">print</span> r1 * r2</span><br><span class="line"><span class="keyword">print</span> r1 / r2</span><br></pre></td></tr></table></figure><p>推荐阅读评论区：<a href="https://www.imooc.com/code/6253" target="_blank" rel="noopener">https://www.imooc.com/code/6253</a></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3/4</span><br><span class="line">1/4</span><br><span class="line">1/8</span><br><span class="line">2/1</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Rational类实现了有理数运算，但是，如果要把结果转为 <code>int</code> 或 <code>float</code> 怎么办？</p><p>考察整数和浮点数的转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">12.34</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float(<span class="number">12</span>)</span><br><span class="line"><span class="number">12.0</span></span><br></pre></td></tr></table></figure><p>如果要把 <code>Rational</code> 转为 <code>int</code>，应该使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = Rational(<span class="number">12</span>, <span class="number">5</span>)</span><br><span class="line">n = int(r)</span><br></pre></td></tr></table></figure><p>要让<code>int()</code>函数正常工作，只需要实现特殊方法<code>__int__()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.p // self.q</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> int(Rational(<span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> int(Rational(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>同理，要让<code>float()</code>函数正常工作，只需要实现特殊方法<code>__float__()</code>。</p><h3 id="编程任务-28"><a href="#编程任务-28" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>请继续完善<code>Rational</code>，使之可以转型为<code>float</code>。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        self.p = p</span><br><span class="line">        self.q = q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.p // self.q</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__float__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> float(self.p)/self.q</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> float(Rational(<span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">print</span> float(Rational(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.5</span><br><span class="line">0.333333333333</span><br></pre></td></tr></table></figure><h2 id="property"><a href="#property" class="headerlink" title="@property"></a><code>@property</code></h2><p>考察 <code>Student</code> 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>当我们想要修改一个 <code>Student</code> 的 <code>scroe</code> 属性时，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student(&apos;Bob&apos;, 59)</span><br><span class="line">s.score = 60</span><br></pre></td></tr></table></figure><p>但是也可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.score = 1000</span><br></pre></td></tr></table></figure><p>显然，直接给属性赋值无法检查分数的有效性。</p><p>如果利用两个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, score):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    def get_score(self):</span><br><span class="line">        return self.__score</span><br><span class="line">    def set_score(self, score):</span><br><span class="line">        if score &lt; 0 or score &gt; 100:</span><br><span class="line">            raise ValueError(&apos;invalid score&apos;)</span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure><p>这样一来，<code>s.set_score(1000)</code> 就会报错。</p><p>这种使用 <code>get/set</code> 方法来封装对一个<strong>属性的访问</strong>在许多面向对象编程的语言中都很常见。</p><p><code>知识点:</code> 但是写 <code>s.get_score()</code> 和 <code>s.set_score()</code> 没有直接写 s.score 来得直接。<br>有没有两全其美的方法？—-有。</p><p>因为Python支持高阶函数，在函数式编程中我们介绍了<code>装饰器函数</code>，可以用<code>装饰器函数</code>把 <code>get/set</code> 方法“装饰”成<code>属性调用</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br></pre></td></tr></table></figure><p>注意: 第一个<code>score(self)</code>是<code>get</code>方法，用<code>@property</code>装饰，第二个<code>score(self, score)</code>是<code>set</code>方法，用<code>@score.setter</code>装饰，<code>@score.setter</code>是前一个<code>@property</code>装饰后的副产品。</p><p>现在，就可以像使用属性一样设置score了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s.score</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">1000</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: invalid score</span><br></pre></td></tr></table></figure><p>说明对 <code>score</code> 赋值实际调用的是 <code>set</code>方法。</p><h3 id="编程任务-29"><a href="#编程任务-29" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>如果没有定义<code>set</code>方法，就不能对“属性”赋值，这时，就可以创建一个只读“属性”。<br>请给<code>Student</code>类加一个<code>grade</code>属性，根据 <code>score</code>计算 <code>A（&gt;=80）、B、C（&lt;60）</code>。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2018-01-04 07:44:12</span></span><br><span class="line"><span class="comment"># @Author  : Your Name (you@example.org)</span></span><br><span class="line"><span class="comment"># @Link    : http://example.org</span></span><br><span class="line"><span class="comment"># @Version : $Id$</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid score'</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">80</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;=<span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="keyword">print</span> s.grade</span><br><span class="line"></span><br><span class="line">s.score = <span class="number">60</span></span><br><span class="line"><span class="keyword">print</span> s.grade</span><br><span class="line"></span><br><span class="line">s.score = <span class="number">99</span></span><br><span class="line"><span class="keyword">print</span> s.grade</span><br></pre></td></tr></table></figure><p><code>@property</code>,可以将python定义的函数“当做”属性访问，从而提供更加友好访问方式<br>注意<code>self.score</code> 不要写成<code>score</code> 会报错。</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">B</span><br><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h2><p>由于Python是动态语言，<strong>任何实例在运行期都可以动态地添加属性。</strong></p><p><code>知识点</code>：如果要限制添加的属性，例如，<code>Student</code>类只允许添加 <code>name、gender和score</code> 这3个属性，就可以利用Python的一个特殊的<code>__slots__</code>来实现。</p><p>顾名思义，<code>__slots__</code>是指一个类允许的属性列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'gender'</span>, <span class="string">'score'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p>现在，对实例进行操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = Student(&apos;Bob&apos;, &apos;male&apos;, 59)</span><br><span class="line">&gt;&gt;&gt; s.name = &apos;Tim&apos; # OK</span><br><span class="line">&gt;&gt;&gt; s.score = 99 # OK</span><br><span class="line">&gt;&gt;&gt; s.grade = &apos;A&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">AttributeError: &apos;Student&apos; object has no attribute &apos;grade&apos;</span><br></pre></td></tr></table></figure><p><code>__slots__</code>的目的是<strong>限制当前类所能拥有的属性，</strong>如果不需要添加任意动态的属性，使用<code>__slots__</code>也能节省内存。</p><h3 id="编程任务-30"><a href="#编程任务-30" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>假设<code>Person</code>类通过<code>__slots__</code>定义了<code>name</code>和<code>gender</code>，请在派生类<code>Student</code>中通过<code>_slots__</code>继续添加<code>score</code>的定义，使<code>Student</code>类可以实现<code>name、gender和score</code> 3个属性。</p></blockquote><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'score'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,gender,score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">        self.gender = gender </span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>, <span class="string">'male'</span>, <span class="number">59</span>)</span><br><span class="line">s.name = <span class="string">'Tim'</span></span><br><span class="line">s.score = <span class="number">99</span></span><br><span class="line"><span class="keyword">print</span> s.score</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h2><p>在Python中，函数其实是一个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'abs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-123</span>)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>由于 <code>f</code> 可以被调用，所以，<code>f</code> 被称为可调用对象。</p><p><strong>所有的函数都是可调用对象。</strong></p><p>一个<code>类实例</code>也可以变成一个可调用对象，只需要实现一个特殊方法<code>__call__()</code>。</p><p>我们把 <code>Person</code> 类变成一个可调用对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, friend)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'My name is %s...'</span> % self.name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'My friend is %s...'</span> % friend</span><br></pre></td></tr></table></figure><p>现在可以对 Person 实例直接调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = Person(&apos;Bob&apos;, &apos;male&apos;)</span><br><span class="line">&gt;&gt;&gt; p(&apos;Tim&apos;)</span><br><span class="line">My name is Bob...</span><br><span class="line">My friend is Tim...</span><br></pre></td></tr></table></figure><p>单看 <code>p(&#39;Tim&#39;)</code>你无法确定 p 是一个函数还是一个类实例，所以，在Python中，函数也是<strong>对象，对象和函数的区别并不显著。</strong></p><h3 id="编程任务-31"><a href="#编程任务-31" class="headerlink" title="编程任务"></a>编程任务</h3><blockquote><p>改进一下前面定义的斐波那契数列：</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    ???</span><br></pre></td></tr></table></figure><p>请加一个<code>__call__</code>方法，让调用更简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = Fib()</span><br><span class="line">&gt;&gt;&gt; print f(10)</span><br><span class="line">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span><br></pre></td></tr></table></figure><p>实现代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        a,b,c = <span class="number">0</span>,<span class="number">1</span>,[]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(num):</span><br><span class="line">            c.append(a)</span><br><span class="line">            a,b = b,a+b</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">f = Fib()</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span><br></pre></td></tr></table></figure><h1 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h1><p>Python的函数式编程：</p><ul><li>函数式与函数的区别。</li><li>支持高阶函数：<ul><li>函数本身可作为变量传入另一个函数。</li><li>抽象度很高的模型。</li><li>内置函数<code>map</code> <code>sorted</code> <code>reduce</code> <code>filter</code>中都有高阶函数应用。</li></ul></li><li>闭包：利用闭包来返回函数</li><li>匿名函数：限制,匿名函数只能有一个表达式：表达式的结果就是匿名函数的返回值。</li><li>装饰器：高阶函数的应用，可以把一个函数装饰成另一个函数。以便能在运行时动态增加函数功能。</li></ul><p>Python的模块和包：</p><ul><li>模块的目的：避免名字冲突。</li><li>包可以看成具有目录层次的模块(<code>__init__.py</code>)</li><li>引用模块</li><li>引用<strong>future</strong>添加新版本中的特性。</li></ul><p>Python的面向对象编程:</p><ul><li>类和实例(类是模板，实例是根据模板创健的对象)</li><li>属性和方法。(可以把属性看成是一个方法？)，绑定到实例的函数对象。</li><li>区分类属性和实例属性(优先级，尽量不要重名)</li></ul><p>类的继承中：</p><ul><li>继承的概念和目的(代码复用)</li><li>多态（从一个父类派生出多个子类。可以使子类具有各自不同的行为。）</li><li>多重继承</li></ul><p>定制类：</p><ul><li>定制类的目的：为了让我们编写的类应用到普通函数中。<code>len()</code> <code>cmp()</code></li><li>特殊方法</li><li>类型转换(把任意类型转化为string类型，int类型)</li><li><code>__call__</code>方法：把实例变成一个可以跟函数一样调用的对象。</li></ul><ol><li>任何数据类型的实例都有一个特殊方法<code>__str__()</code>类似于<code>toString</code></li><li>特殊方法的特征：<ul><li>特殊方法定义在class中</li><li>不需要直接调用</li><li>Python的某些函数或者操作符会调用对应的特殊方法</li></ul></li><li><p>正确实现特殊方法：<br> 只需要编写用到的特殊方法<br> 有关联性的特殊方法都必须实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如 __getattr__</span><br><span class="line">   __setattr__</span><br><span class="line">   __delattr__</span><br></pre></td></tr></table></figure></li><li><p>python中<code>__str__</code>和<code>__repr__</code><br>如果要把一个类的实例变成 <code>str</code>，就需要实现特殊方法<code>__str__()</code>：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.gender = gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(Person: %s, %s)'</span> % (self.name, self.gender)</span><br></pre></td></tr></table></figure><p><code>__str__()</code>用于显示给用户，而<code>__repr__()</code>用于显示给开发人员。</p><p>有一个偷懒的定义<code>__repr__</code>的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#正常定义完__str__后</span><br><span class="line">__repr__ = __str__  #把__str__赋予__repr__</span><br></pre></td></tr></table></figure><ol><li>特殊方法之 <code>__cmp__</code><br>对一组 <code>Student</code> 类的实例排序时，就必须提供我们自己的特殊方法 <code>__cmp__()</code>：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__cmp__</span><span class="params">(self, s)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> self.name &lt; s.name:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">       <span class="keyword">elif</span> self.name &gt; s.name:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上述 <code>Student</code> 类实现了<code>__cmp__()</code>方法，<code>__cmp__</code>用实例自身<code>self</code>和传入的实例 <code>s</code>进行比较.</p><ol><li><p>在<code>class</code>中定义<code>__init__(self),__float__(self)</code>方法：数据类型转换</p></li><li><p>python中 <code>@property</code><br><code>get/set</code> 方法来封装对一个属性的访问<br>用装饰器函数把 <code>get/set</code> 方法“装饰”成属性调用</p></li></ol><p><code>@property和@method.setter</code>是搭配使用的，<br><code>@property</code>对应<code>get</code>方法（相当于只读不可更改），<code>@method.setter</code>对应<code>set</code>方法。</p><ol><li>python中<code>__slots__</code><br>任何实例在运行期都可以动态地添加属性<br>如果要限制添加的属性，例如，<code>Student</code>类只允许添加 <code>name、gender和score</code> 这3个属性，<br>就可以利用Python的一个特殊的<code>__slots__</code>来实现。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__slots__ = (&apos;name&apos;, &apos;gender&apos;, &apos;score&apos;)</span><br></pre></td></tr></table></figure><p>顾名思义，<code>__slots__</code>是指一个类允许的属性列表</p><p>子类继续父类的场合：<br><code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的。<br>除非在子类中也定义<code>__slots__</code>，此时，子类允许定义的属性就是自身的<code>__slots__加上父类中定义的__slots__</code>。</p><p>下一步进阶：</p><ul><li>IO：文件和Socket</li><li>多任务：进程和线程</li><li>数据库</li><li>Web开发</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/post/1d8f9861.html">Python进阶学习笔记</a></p><p><span>文章作者:</span><a href="/" title="访问 mtianyan 的个人博客">mtianyan</a></p><p><span>发布时间:</span>2018年01月03日 - 16:01</p><p><span>最后更新:</span>2018年01月05日 - 04:01</p><p><span>原始链接:</span><a href="/post/1d8f9861.html" title="Python进阶学习笔记">http://blog.mtianyan.cn/post/1d8f9861.html</a><span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://blog.mtianyan.cn/post/1d8f9861.html" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>请博主吃包辣条</div> <button id="rewardButton" disable="enable" onclick='var qr=document.getElementById("QR");"none"===qr.style.display?qr.style.display="block":qr.style.display="none"'> <span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"> <img id="wechat_qr" src="/images/wechatpay.png" alt="mtianyan 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"> <img id="alipay_qr" src="/images/alipay.jpg" alt="mtianyan 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a><a href="/tags/进阶学习/" rel="tag"><i class="fa fa-tag"></i> 进阶学习</a><a href="/tags/学习笔记/" rel="tag"><i class="fa fa-tag"></i> 学习笔记</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/post/7a862501.html" rel="next" title="Python零基础入门笔记"><i class="fa fa-chevron-left"></i> Python零基础入门笔记</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article><div class="post-spread"><div class="jiathis_style"> <span class="jiathis_txt">分享到：</span> <a class="jiathis_button_fav">收藏夹</a> <a class="jiathis_button_copy">复制网址</a> <a class="jiathis_button_email">邮件</a> <a class="jiathis_button_weixin">微信</a> <a class="jiathis_button_qzone">QQ空间</a> <a class="jiathis_button_tqq">腾讯微博</a> <a class="jiathis_button_douban">豆瓣</a> <a class="jiathis_button_share">一键分享</a> <a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a><a class="jiathis_counter_style"></a></div><script type="text/javascript">var jiathis_config={data_track_clickback:!0,summary:"",shortUrl:!1,hideMore:!1}</script><script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2154292" charset="utf-8"></script></div></div></div><div class="comments" id="comments"><div id="SOHUCS"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="mtianyan"><p class="site-author-name" itemprop="name">mtianyan</p><p class="site-description motion-element" itemprop="description">爱分享，爱技术，爱生活。</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">16</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/mtianyan" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://www.jianshu.com/u/db9a7a0daa1f" target="_blank" title="简书"><i class="fa fa-fw fa-book"></i> 简书</a></span><span class="links-of-author-item"><a href="https://plus.google.com/u/0/114963812195952881148" target="_blank" title="Google"><i class="fa fa-fw fa-google"></i> Google</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://mtianyan.gitee.io/" title="本站孪生站(国内码云托管)" target="_blank">本站孪生站(国内码云托管)</a></li></ul></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#打好基础再来进阶"><span class="nav-number">1.</span> <span class="nav-text">打好基础再来进阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python函数式编程"><span class="nav-number">2.</span> <span class="nav-text">Python函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程简介"><span class="nav-number">2.1.</span> <span class="nav-text">函数式编程简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数"><span class="nav-number">2.2.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把函数作为参数"><span class="nav-number">2.3.</span> <span class="nav-text">把函数作为参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务"><span class="nav-number">2.3.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-函数"><span class="nav-number">2.4.</span> <span class="nav-text">map()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reduce-函数"><span class="nav-number">2.5.</span> <span class="nav-text">reduce()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-2"><span class="nav-number">2.5.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filter-函数"><span class="nav-number">2.6.</span> <span class="nav-text">filter()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-3"><span class="nav-number">2.6.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义排序函数"><span class="nav-number">2.7.</span> <span class="nav-text">自定义排序函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-4"><span class="nav-number">2.7.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#返回函数"><span class="nav-number">2.8.</span> <span class="nav-text">返回函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-5"><span class="nav-number">2.8.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">2.9.</span> <span class="nav-text">闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-天涯"><span class="nav-number">2.9.1.</span> <span class="nav-text">编程任务(天涯)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数"><span class="nav-number">2.10.</span> <span class="nav-text">匿名函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-6"><span class="nav-number">2.10.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python中的装饰器"><span class="nav-number">2.11.</span> <span class="nav-text">Python中的装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写无参数decorator"><span class="nav-number">2.12.</span> <span class="nav-text">编写无参数decorator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用"><span class="nav-number">2.12.1.</span> <span class="nav-text">应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-天涯-1"><span class="nav-number">2.12.2.</span> <span class="nav-text">编程任务(天涯)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编写带参数decorator"><span class="nav-number">2.13.</span> <span class="nav-text">编写带参数decorator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-天涯-2"><span class="nav-number">2.13.1.</span> <span class="nav-text">编程任务(天涯)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完善decorator"><span class="nav-number">2.14.</span> <span class="nav-text">完善decorator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-7"><span class="nav-number">2.14.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏函数"><span class="nav-number">2.15.</span> <span class="nav-text">偏函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-8"><span class="nav-number">2.15.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python的模块"><span class="nav-number">3.</span> <span class="nav-text">Python的模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块和包。"><span class="nav-number">3.1.</span> <span class="nav-text">模块和包。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入模块"><span class="nav-number">3.2.</span> <span class="nav-text">导入模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-9"><span class="nav-number">3.2.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态导入模块"><span class="nav-number">3.3.</span> <span class="nav-text">动态导入模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-10"><span class="nav-number">3.3.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用future"><span class="nav-number">3.4.</span> <span class="nav-text">使用future</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-11"><span class="nav-number">3.4.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装第三方模块"><span class="nav-number">3.5.</span> <span class="nav-text">安装第三方模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python面向对象编程"><span class="nav-number">4.</span> <span class="nav-text">Python面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象简介"><span class="nav-number">4.1.</span> <span class="nav-text">面向对象简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义类并创建实例"><span class="nav-number">4.2.</span> <span class="nav-text">定义类并创建实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-12"><span class="nav-number">4.2.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建实例属性"><span class="nav-number">4.3.</span> <span class="nav-text">创建实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-13"><span class="nav-number">4.3.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化实例属性"><span class="nav-number">4.4.</span> <span class="nav-text">初始化实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-14"><span class="nav-number">4.4.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问限制"><span class="nav-number">4.5.</span> <span class="nav-text">访问限制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-15"><span class="nav-number">4.5.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建类属性"><span class="nav-number">4.6.</span> <span class="nav-text">创建类属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-16"><span class="nav-number">4.6.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类属性和实例属性名字冲突怎么办"><span class="nav-number">4.7.</span> <span class="nav-text">类属性和实例属性名字冲突怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-17"><span class="nav-number">4.7.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义实例方法"><span class="nav-number">4.8.</span> <span class="nav-text">定义实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-18"><span class="nav-number">4.8.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法也是属性"><span class="nav-number">4.9.</span> <span class="nav-text">方法也是属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-19"><span class="nav-number">4.9.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义类方法"><span class="nav-number">4.10.</span> <span class="nav-text">定义类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-20"><span class="nav-number">4.10.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python类的继承"><span class="nav-number">5.</span> <span class="nav-text">Python类的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是继承"><span class="nav-number">5.1.</span> <span class="nav-text">什么是继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承一个类"><span class="nav-number">5.2.</span> <span class="nav-text">继承一个类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-21"><span class="nav-number">5.2.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断类型"><span class="nav-number">5.3.</span> <span class="nav-text">判断类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-22"><span class="nav-number">5.3.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态"><span class="nav-number">5.4.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-23"><span class="nav-number">5.4.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-number">5.5.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-24"><span class="nav-number">5.5.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取对象信息-知识点"><span class="nav-number">5.6.</span> <span class="nav-text">获取对象信息(知识点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-25"><span class="nav-number">5.6.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Python的特殊方法-魔术方法"><span class="nav-number">6.</span> <span class="nav-text">Python的特殊方法(魔术方法)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是特殊方法？"><span class="nav-number">6.1.</span> <span class="nav-text">什么是特殊方法？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#str-和-repr"><span class="nav-number">6.2.</span> <span class="nav-text">__str__和__repr__</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-26"><span class="nav-number">6.2.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cmp"><span class="nav-number">6.3.</span> <span class="nav-text">__cmp__</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-27"><span class="nav-number">6.3.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#len"><span class="nav-number">6.4.</span> <span class="nav-text">__len__</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-天涯-3"><span class="nav-number">6.4.1.</span> <span class="nav-text">编程任务(天涯)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数学运算"><span class="nav-number">6.5.</span> <span class="nav-text">数学运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-天涯-4"><span class="nav-number">6.5.1.</span> <span class="nav-text">编程任务(天涯)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型转换"><span class="nav-number">6.6.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-28"><span class="nav-number">6.6.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property"><span class="nav-number">6.7.</span> <span class="nav-text">@property</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-29"><span class="nav-number">6.7.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slots"><span class="nav-number">6.8.</span> <span class="nav-text">__slots__</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-30"><span class="nav-number">6.8.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call"><span class="nav-number">6.9.</span> <span class="nav-text">__call__</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编程任务-31"><span class="nav-number">6.9.1.</span> <span class="nav-text">编程任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#课程总结"><span class="nav-number">7.</span> <span class="nav-text">课程总结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">mtianyan</span><div class="theme-info"><div class="powered-by"></div> <span class="post-count">博客全站共85.2k字</span></div></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span class="site-uv">本站访客数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人次</span> <span class="site-pv">本站总访问量<span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script><script type="text/javascript">!function(){var t="1eb79150519fd9b791c77e8eef6f3632";if((window.innerWidth||document.documentElement.clientWidth)<960)window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=cyrJmJ3rL&conf='+t+'"><\/script>');else{!function(t,e){var n=document.getElementsByTagName("head")[0]||document.head||document.documentElement,a=document.createElement("script");a.setAttribute("type","text/javascript"),a.setAttribute("charset","UTF-8"),a.setAttribute("src",t),"function"==typeof e&&(window.attachEvent?a.onreadystatechange=function(){var t=a.readyState;"loaded"!==t&&"complete"!==t||(a.onreadystatechange=null,e())}:a.onload=e),n.appendChild(a)}("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:"cyrJmJ3rL",conf:t})})}}()</script><script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script><script type="text/javascript">var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")};function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){var r=!1,s=0,a=0,i=n.title.trim(),c=i.toLowerCase(),l=n.content.trim().replace(/<[^>]+>/g,""),h=l.toLowerCase(),p=decodeURIComponent(n.url),u=[],f=[];if(""!=i&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}u=u.concat(e(t,c,!1)),f=f.concat(e(t,h,!1))}),(u.length>0||f.length>0)&&(r=!0,s=u.length+f.length)),r){[u,f].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});function d(e,o,n,r){for(var s=r[r.length-1],i=s.position,c=s.word,l=[],h=0;i+c.length<=n&&0!=r.length;){c===t&&h++,l.push({position:i,length:c.length});var p=i+c.length;for(r.pop();0!=r.length&&(i=(s=r[r.length-1]).position,c=s.word,p>i);)r.pop()}return a+=h,{hits:l,start:o,end:n,searchTextCount:h}}var g=[];0!=u.length&&g.push(d(0,0,i.length,u));for(var v=[];0!=f.length;){var $=f[f.length-1],C=$.position,m=$.word,x=C-20,w=C+80;x<0&&(x=0),w<C+m.length&&(w=C+m.length),w>l.length&&(w=l.length),v.push(d(0,x,w,f))}v.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var y=parseInt("1");y>=0&&(v=v.slice(0,y));function T(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var b="";0!=g.length?b+="<li><a href='"+p+"' class='search-result-title'>"+T(i,g[0])+"</a>":b+="<li><a href='"+p+"' class='search-result-title'>"+i+"</a>",v.forEach(function(t){b+="<a href='"+p+'\'><p class="search-result">'+T(l,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:a,hitCount:s,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),!1===isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){27===t.which&&$(".search-popup").is(":visible")&&onPopupClose()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("2uqmIjYredIvFy6tEXbKG4Fj-gzGzoHsz","CWl1rE8cQlIseOg2Cq3hzxYi")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var i=0;i<e.length;i++){var s=e[i],r=s.get("url"),l=s.get("time"),c=document.getElementById(r);$(c).find(t).text(l)}for(i=0;i<n.length;i++){r=n[i],c=document.getElementById(r);var u=$(c).find(t);""==u.text()&&u.text(0)}}else o.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){$(document.getElementById(n)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var s=new e,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),s.setACL(r),s.set("title",o),s.set("url",n),s.set("time",1),s.save(null,{success:function(e){$(document.getElementById(n)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script><script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><div id="hexo-helper-live2d"><canvas id="live2dcanvas" width="150" height="300"></canvas></div><style>#live2dcanvas{position:fixed;width:150px;height:300px;opacity:.7;right:-30px;z-index:999;pointer-events:none;bottom:40px}</style><script type="text/javascript" src="/live2d/device.min.js"></script><script type="text/javascript">
const loadScript = function loadScript(c,b){var a=document.createElement("script");a.type="text/javascript";"undefined"!=typeof b&&(a.readyState?a.onreadystatechange=function(){if("loaded"==a.readyState||"complete"==a.readyState)a.onreadystatechange=null,b()}:a.onload=function(){b()});a.src=c;document.body.appendChild(a)};
(function(){
  if((typeof(device) != 'undefined') && (device.mobile())){
    var trElement = document.getElementById('hexo-helper-live2d');
    trElement.parentNode.removeChild(trElement);
    return;
  }else
    if (typeof(device) === 'undefined') console.error('Cannot find current-device script.');
  loadScript("/live2d/script.js", function(){loadlive2d("live2dcanvas", "/live2d/assets/hijiki.model.json", 0.5);});
})();
</script></body></html><script type="text/javascript" src="/js/src/love.js"></script>